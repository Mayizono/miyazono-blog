<!-- build time:Tue Sep 07 2021 23:32:01 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="冬樱茶" href="https://github.com/Mayizono/miyazono.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="冬樱茶" href="https://github.com/Mayizono/miyazono.github.io/atom.xml"><link rel="alternate" type="application/json" title="冬樱茶" href="https://github.com/Mayizono/miyazono.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://github.com/Mayizono/miyazono.github.io/big-data/spark/2.Spark%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%BC%96%E7%A8%8B/"><title>| Yume Shoka = 冬樱茶</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline"></h1><div class="meta"><span class="item" title="创建时间：2021-08-31 18:42:35"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-08-31T18:42:35+08:00">2021-08-31</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>41k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>37 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Yume Shoka</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeu7txpzj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipesx5fdwj20zk0m81kx.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicit4jrvuj20zk0m8785.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclxxcb6rj20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclhpw3lwj20zk0m8gvw.jpg"></li><li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicitspjpbj20zk0m81ky.jpg"></li></ul></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://github.com/Mayizono/miyazono.github.io/big-data/spark/2.Spark%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%BC%96%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Miyazono"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="冬樱茶"></span><div class="body md" itemprop="articleBody"><h1 id="spark架构及编程"><a class="anchor" href="#spark架构及编程">#</a> Spark 架构及编程</h1><hr><h2 id="接spark环境的安装"><a class="anchor" href="#接spark环境的安装">#</a> 接 Spark 环境的安装</h2><h2 id="四-spark运行框架"><a class="anchor" href="#四-spark运行框架">#</a> 四、Spark 运行框架</h2><h3 id="41-运行框架"><a class="anchor" href="#41-运行框架">#</a> 4.1 运行框架</h3><p>![image-20200602225134787](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200602225135.png)</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. Spark 框架可以理解三个部分组成</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>第一部分： Driver <span class="token operator">+</span> Executor  <span class="token comment">-->  任务执行和调度</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>第二部分： Master <span class="token operator">+</span> Worker    <span class="token comment">-->  Saprk 自身的资源调度框架</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>第三部分： Cluster Manager    <span class="token comment">-->  集群管理，中间件</span></pre></td></tr></table></figure><ol><li><mark>Driver + Executor</mark></li></ol><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- Driver：驱动器</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	<span class="token number">1.</span> 用于执行Spark任务中的main<span class="token punctuation">(</span><span class="token punctuation">)</span>方法，负责实际代码的执行</pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token number">2.</span> 将用户程序转化为job；</pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token number">3.</span> 调度Executor之间的任务<span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token number">4.</span> 跟踪Executor的执行情况；</pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token number">5.</span> 通过UI展示查询运行的结果。</pre></td></tr><tr><td data-num="7"></td><td><pre>	</pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">-- Executor: 执行器</span></pre></td></tr><tr><td data-num="9"></td><td><pre> 	<span class="token number">1.</span> 是worker的一个JVM进程，负责Spark执行具体的任务<span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> 	<span class="token number">2.</span> 负责运行组成Spark应用的任务，并将结果返回给驱动器进程；</pre></td></tr><tr><td data-num="11"></td><td><pre> 	<span class="token number">3.</span> 在执行器内有块管理器，为用户程序中要求缓存的RDD提供内存的缓存。</pre></td></tr></table></figure><ol start="2"><li><mark>Master + worker</mark></li></ol><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- Master</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token number">1.</span> 类似YARN中的RM<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token number">2.</span> 负责资源的调度和分配，并进行集群的监控</pre></td></tr><tr><td data-num="4"></td><td><pre> </pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token comment">-- worker</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token number">1.</span> 类似YARN中的NM；</pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token number">2.</span> 是一个进程，一个Worker运行在集群的一个服务器上，由Master分配资源对数据进行并行的处理和计算。</pre></td></tr><tr><td data-num="8"></td><td><pre>    </pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token comment">-- 只有独立部署的模式下才有 Master 和 Worker.</span></pre></td></tr></table></figure><ol start="3"><li><mark>ApplicationMaster</mark></li></ol><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>ApplicationMaster就是用来为RM<span class="token punctuation">(</span>资源<span class="token punctuation">)</span> 和Driver<span class="token punctuation">(</span>计算<span class="token punctuation">)</span> 之间解耦合</pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">-- 如何理解解耦合？</span></pre></td></tr><tr><td data-num="4"></td><td><pre>Application作为Driver和RM的中间人，Driver和RM不需要直接连接，这样当Driver出现变动时，RM并不需要做任何代码的修改，也就是"你的改变，我看不见<span class="token operator">~</span><span class="token operator">~</span></pre></td></tr></table></figure><p>![image-20200603085844513](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200603085844.png)</p><h3 id="42-核心概念"><a class="anchor" href="#42-核心概念">#</a> 4.2 核心概念</h3><h4 id="421-执行器exerutor"><a class="anchor" href="#421-执行器exerutor">#</a> 4.2.1 执行器 Exerutor</h4><p>如下是执行器的参数，有执行器的个数、每个执行器的内存大小、每个执行器虚拟的 CPU 的核数</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>--num-executors</td><td>配置 Executor 的数量</td></tr><tr><td>--executor-memory</td><td>配置每个 Executor 的内存大小</td></tr><tr><td>--executor-cores</td><td>配置每个 Executor 的虚拟 CPU core 数量</td></tr></tbody></table><h4 id="422-并行度parallelism"><a class="anchor" href="#422-并行度parallelism">#</a> 4.2.2 并行度（Parallelism）</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 什么是并行度</span></pre></td></tr><tr><td data-num="2"></td><td><pre>整个集群并行执行任务的数量称为并行度。</pre></td></tr></table></figure><h4 id="423-有向无环图dag"><a class="anchor" href="#423-有向无环图dag">#</a> 4.2.3 有向无环图（DAG）</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 什么是有向无环图</span></pre></td></tr><tr><td data-num="2"></td><td><pre>DAG<span class="token punctuation">(</span>Directed Acycli Graph<span class="token punctuation">)</span>:由点和线组成的拓扑图形，该图形具有方向，不会闭环。</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">-- tez ：是作业和作业之间的有向无环图</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">-- Spark：是作业内部的有向无环图</span></pre></td></tr></table></figure><p>![image-20200602232357360](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200602232357.png)</p><h4 id="424-提交流程"><a class="anchor" href="#424-提交流程">#</a> 4.2.4 提交流程</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token string">"先作为了解，后续再详细讲解"</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Spark应用程序提交到Yarn环境中执行的时候，一般会有两种部署执行的方式：Client和Cluster。两种模式，主要区别在于：<span class="token string">"Driver程序的运行节点"</span></pre></td></tr></table></figure><p>![image-20200602232448093](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200602232448.png)</p><h2 id="五-spark核心编程"><a class="anchor" href="#五-spark核心编程">#</a> 五、Spark 核心编程</h2><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--Spark 计算框架为了提供高吞吐、高并发的数据处理，提供了三大数据结构，处理不同数据的应用场景。</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>框架<span class="token number">1</span>：RDD：<span class="token punctuation">(</span>Resillient distribute dataset<span class="token punctuation">)</span> 弹性分布式数据集</pre></td></tr><tr><td data-num="4"></td><td><pre>框架<span class="token number">2</span>：累加器：分布式共享<span class="token string">"只写"</span>变量</pre></td></tr><tr><td data-num="5"></td><td><pre>框架<span class="token number">3</span>：广播变量：分布式共享<span class="token string">"只读"</span>变量</pre></td></tr></table></figure><h3 id="51-rdd"><a class="anchor" href="#51-rdd">#</a> 5.1 RDD</h3><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 什么是 RDD?</span></pre></td></tr><tr><td data-num="2"></td><td><pre>弹性分布式数据集，一种数据处理的<span class="token string">"模型"</span><span class="token operator">&amp;</span><span class="token string">"数据结构"</span>，<span class="token string">"可以理解为在java中我们创建了一个类，在类中构建了很多属性和方法，然后最后使用一个行动算子，将这些方法全部启动运行，并将运行的结果返回"</span>，是一个抽象类。如汽车模型，航母模型、手机模型等。</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">-- RDD 的特点：</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token number">1.</span> 可分区：提高消费能力，更适合并发计算，类似kafka的消费者消费数据，<span class="token string">"一个分区对应一个task，在executor中，一个core对应一个task，这样就体现了并发计算"</span>。</pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token number">2.</span> 弹性：变化，可变。</pre></td></tr><tr><td data-num="7"></td><td><pre>		a、存储弹性：可以在磁盘和内存之间自动切换；<span class="token string">"shuffle阶段，就会将数据存入磁盘中，避免数据量过大，导致任务失败。一个任务分很多个阶段，每个阶段内的运行，则是基于内存的。"</span></pre></td></tr><tr><td data-num="8"></td><td><pre>		b、容错弹性：数据丢失可以自动恢复；</pre></td></tr><tr><td data-num="9"></td><td><pre>		c、计算弹性：计算出错后重试机制；</pre></td></tr><tr><td data-num="10"></td><td><pre>		d、分区弹性： 根据计算结果动态改变分区的数量。<span class="token string">"每次计算以后，可能数据会减少，这样一来，就会造成数据倾斜的状况，通过动态修改分区的数量，这样就可以数据使尽量均匀分布在不同的分区内。"</span></pre></td></tr><tr><td data-num="11"></td><td><pre>     <span class="token number">3.</span> 不可变：类似不可变集合</pre></td></tr><tr><td data-num="12"></td><td><pre>          RDD只存储计算的逻辑，不存储数据，计算的逻辑是不可变的，一旦改变，则会创建新的RDD；</pre></td></tr><tr><td data-num="13"></td><td><pre>     <span class="token number">4.</span> RDD ：一个抽象类，需要子类具体实现<span class="token punctuation">,</span>说明有很多种数据处理方式</pre></td></tr></table></figure><h3 id="52-io"><a class="anchor" href="#52-io">#</a> 5.2 IO</h3><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- IO 流分为：</span></pre></td></tr><tr><td data-num="2"></td><td><pre>          字节流          字符流</pre></td></tr><tr><td data-num="3"></td><td><pre>输入流   inputStream       <span class="token keyword">read</span></pre></td></tr><tr><td data-num="4"></td><td><pre>输出流   outPutStream      <span class="token keyword">write</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>节点流  <span class="token keyword">File</span> <span class="token operator">+</span> 字符流<span class="token operator">/</span>字节流</pre></td></tr><tr><td data-num="7"></td><td><pre>处理流  buffer  <span class="token operator">+</span> <span class="token punctuation">(</span> <span class="token keyword">File</span><span class="token operator">+</span> 字符流<span class="token operator">/</span>字节流 <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">-- 解读如下三张图流程</span></pre></td></tr><tr><td data-num="10"></td><td><pre>图<span class="token number">1</span>：使用字节流读取一个文件的内容并打印到控制台，使用一个文件节点流，一次只能读取一部分数据，然后打印，然后再读取一部分数据，再进行打印，慢；</pre></td></tr><tr><td data-num="11"></td><td><pre>图<span class="token number">2</span>：增加一个缓冲流，将获取的数据暂时先存放在内存的一个缓冲区内，等到达一定的数据量以后，再统一处理；</pre></td></tr><tr><td data-num="12"></td><td><pre>图<span class="token number">3</span>：发现字节流获取的数据，打印到控制台，我们是不认识的，中间使用一个字节流转字符流，将读取的数据转化为字符流，然后再将字符缓存到内存，待达到一定的数据量以后，再往控制台上打印。</pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>综上，发现，如上的过程属于装饰者设计模式，前者的结果传递到后者，一层一层的包裹起来。</pre></td></tr></table></figure><p>![image-20200602235042403](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200602235042.png)</p><p>![image-20200602235122170](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200602235122.png)</p><p>![image-20200602235154706](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200602235154.png)</p><h3 id="53-rdd执行原理"><a class="anchor" href="#53-rdd执行原理">#</a> 5.3 RDD 执行原理</h3><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- RDD 的执行原理：</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">1.</span> 类似IO处理；</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">2.</span> 装饰者设计模式，通过new的方式体现装饰者设计模式；</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">3.</span> 延迟加载，RDD只是封装了逻辑，只要当行动算子<span class="token string">"如collect()"</span>执行时，才会开始执行整个逻辑。</pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">-- 与 IO 的区别：</span></pre></td></tr><tr><td data-num="7"></td><td><pre>RDD不保存数据，只保留逻辑；</pre></td></tr><tr><td data-num="8"></td><td><pre>IO会保存数据</pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">-- 如何理解 RDD</span></pre></td></tr><tr><td data-num="11"></td><td><pre>不可变集合 <span class="token comment">--> 增加新的数据 --> 创建新的集合</span></pre></td></tr><tr><td data-num="12"></td><td><pre>RDD <span class="token comment">--> 扩展新的功能 --> 创建新的 RDD</span></pre></td></tr></table></figure><p>&lt;img src=&quot;<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200603000038.png&quot; alt=&quot;image-20200603000038108&quot; /&gt;</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 解读 RDD：</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">1.</span> Executor有多个core</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">2.</span> 默认一个分区生成一个task</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">3.</span> 一个task由一个core执行</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">4.</span> 所以一个Executor可以执行多个task</pre></td></tr></table></figure><p>![image-20200603101333142](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200603101333.png)</p><h3 id="54-rdd的核心属性"><a class="anchor" href="#54-rdd的核心属性">#</a> 5.4 RDD 的核心属性</h3><h4 id="541-分区列表"><a class="anchor" href="#541-分区列表">#</a> 5.4.1 分区列表</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 什么是分区列表</span></pre></td></tr><tr><td data-num="2"></td><td><pre>就是RDD中的多个分区</pre></td></tr></table></figure><p>![image-20200603003135290](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200603003135.png)</p><h4 id="542-分区计算函数"><a class="anchor" href="#542-分区计算函数">#</a> 5.4.2 分区计算函数</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 什么是分区计算函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre>就是RDD中的计算逻辑，不同的分区具有相同的计算逻辑。</pre></td></tr></table></figure><p>![image-20200603003153013](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200603003153.png)</p><h4 id="543-rdd之间的依赖关系"><a class="anchor" href="#543-rdd之间的依赖关系">#</a> 5.4.3 RDD 之间的依赖关系</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 什么是 RDD 之间的依赖关系</span></pre></td></tr><tr><td data-num="2"></td><td><pre>当需求中需要将多个计算模型进行组合时，就需要将多个RDD建立依赖关系</pre></td></tr><tr><td data-num="3"></td><td><pre>之所以有依赖关系，是因为假如将所有的执行逻辑封装在一个RDD中时，那么不知道哪个先执行，哪个后执行。</pre></td></tr></table></figure><p>![image-20200603003356558](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200603003356.png)</p><h4 id="544-分区器可选"><a class="anchor" href="#544-分区器可选">#</a> 5.4.4 分区器（可选）</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 什么是分区器</span></pre></td></tr><tr><td data-num="2"></td><td><pre>数据进入分区的规则，对数据进行分区。</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">1.</span> 只能是KV键值对的数据可以指定进入分区的规则</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">2.</span> 默认没有分区器</pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token string">"分区器和分区的个数有什么关系呢？"</span></pre></td></tr><tr><td data-num="7"></td><td><pre>分区器：是一种规则，针对kv数据结构的rdd，指明什么样的数据进入哪个分区</pre></td></tr></table></figure><p>![image-20200603003507224](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200603003507.png)</p><h4 id="545-首选位置可选"><a class="anchor" href="#545-首选位置可选">#</a> 5.4.5 首选位置（可选）</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 什么是首选位置</span></pre></td></tr><tr><td data-num="2"></td><td><pre>根据本地化级别，确定task去到哪一个Executor中进行计算</pre></td></tr></table></figure><p>![image-20200603003641655](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200603003641.png)</p><p>![](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200603003308.png)</p><h3 id="55-基础编程"><a class="anchor" href="#55-基础编程">#</a> 5.5 基础编程</h3><h4 id="551-创建rdd"><a class="anchor" href="#551-创建rdd">#</a> 5.5.1 创建 RDD</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 4 种创建 RDD 的方式：</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token number">1.</span> 从内存<span class="token punctuation">(</span>集合<span class="token punctuation">)</span>中创建</pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token number">2.</span> 从磁盘中创建</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token number">3.</span> 从其他RDD中创建：RDD调用新的逻辑就是创建新的RDD</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token number">4.</span> 直接创建：通过new的方式，spark框架内部会使用</pre></td></tr></table></figure><h5 id="5511-从内存集合中创建"><a class="anchor" href="#5511-从内存集合中创建">#</a> 5.5.1.1 从内存 (集合) 中创建</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 方法 1：parallelize (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token number">1.</span> 方法：使用parallelize<span class="token punctuation">(</span>形参<span class="token punctuation">)</span>：创建一个RDD</pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token number">2.</span> 形参：有两个参数：</pre></td></tr><tr><td data-num="4"></td><td><pre>       <span class="token string">"参数1"</span>：seq:Seq<span class="token punctuation">[</span>T<span class="token punctuation">]</span>，带泛型的序列，可以传递一个List集合</pre></td></tr><tr><td data-num="5"></td><td><pre>       <span class="token string">"参数2"</span>：numSlices：<span class="token keyword">int</span> <span class="token operator">=</span> defaultParallelism，分片的数量，<span class="token string">"后面讲平行度和分区时详细讲"</span>。</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token comment">-- 方法 2：makeRDD (形参)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token number">1.</span>发现：底层还是调用了parallelize方法，所以参数和parallelize方法一模一样，只是方法名更好理解</pre></td></tr><tr><td data-num="9"></td><td><pre>      	源码：</pre></td></tr><tr><td data-num="10"></td><td><pre>      	parallelize<span class="token punctuation">(</span>seq<span class="token punctuation">,</span> numSlices<span class="token punctuation">)</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 构建 Spark 的环境和创建和 Spark 的连接说明</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">/*</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    setMaster (master：String)：指明 Spark 运行的环境</pre></td></tr><tr><td data-num="4"></td><td><pre>    形参：local []    学习期间暂时使用本地环境</pre></td></tr><tr><td data-num="5"></td><td><pre>    local [1]: 代表单核</pre></td></tr><tr><td data-num="6"></td><td><pre>    local [4]: 代表 4 核</pre></td></tr><tr><td data-num="7"></td><td><pre>    local [*]: 代表最大核数，在设备管理器中可以查看，我的电脑是 12 核</pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    SetAppName (name:String): 执行程序的名称。</pre></td></tr><tr><td data-num="10"></td><td><pre>     */</pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">val</span> sparkConf<span class="token operator">:</span> SparkConf <span class="token operator">=</span> <span class="token keyword">new</span> SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setAppName<span class="token punctuation">(</span><span class="token string">"wordCount"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">val</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> SparkContext<span class="token punctuation">(</span>sparkConf<span class="token punctuation">)</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">// 方法 1：parallelize (list)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">val</span> datas<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>parallelize<span class="token punctuation">(</span>list<span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="5"></td><td><pre>    datas<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span><span class="token comment">//local, 单核，数据只存在一个分区</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    datas<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output1"</span><span class="token punctuation">)</span><span class="token comment">//local [3], 三核，数据存在 3 个分区</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    datas<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output2"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token comment">//local [*], 最大核数：12 核，生成 12 个分区，但是由于 list 数据没有那么多，所以有些分区没有数据</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token comment">// 方法 2：makeRDD (list)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token comment">// 将 RDD 的处理后的数据保存到分区文件中</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    rdd<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output3"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="5512-从外部disk存储中创建rdd"><a class="anchor" href="#5512-从外部disk存储中创建rdd">#</a> 5.5.1.2 从外部 (Disk) 存储中创建 RDD</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 从本地磁盘中创建 RDD</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token number">1.</span> 方法：textFile<span class="token punctuation">(</span>形参<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token number">2.</span> 形参：有两个参数</pre></td></tr><tr><td data-num="4"></td><td><pre>       <span class="token string">"参数1"</span>：path:String，表示文件的路径</pre></td></tr><tr><td data-num="5"></td><td><pre>              <span class="token string">"表示方式"</span>：</pre></td></tr><tr><td data-num="6"></td><td><pre>              a、可以表示一个文件</pre></td></tr><tr><td data-num="7"></td><td><pre>              b、可以表示一个文件夹</pre></td></tr><tr><td data-num="8"></td><td><pre>              c、还可以使用通配符<span class="token string">"星号"</span>的方式表示多个文件</pre></td></tr><tr><td data-num="9"></td><td><pre>              如val rdd: RDD<span class="token punctuation">[</span>String<span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token string">"input/*.txt"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>              <span class="token string">"路径说明"</span>：</pre></td></tr><tr><td data-num="11"></td><td><pre>              a、可以是相对路径，在IDEA中，从当前项目的根目录下往下找，path路径根据环境的不同自动发生改变</pre></td></tr><tr><td data-num="12"></td><td><pre>              b、也可以是绝对路径</pre></td></tr><tr><td data-num="13"></td><td><pre>              c、还可以指向第三方存储路径，如HDFS</pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token string">"参数2"</span>：minPartitions：<span class="token keyword">Int</span> <span class="token operator">=</span> defaultMinPartitions</pre></td></tr><tr><td data-num="15"></td><td><pre>              指建议产生的RDD的最小分区数，<span class="token string">"后面与并行度重点展开"</span>。</pre></td></tr><tr><td data-num="16"></td><td><pre>          	  suggested minimum number <span class="token keyword">of</span> partitions <span class="token keyword">for</span> the resulting RDD</pre></td></tr><tr><td data-num="17"></td><td><pre>          	  </pre></td></tr><tr><td data-num="18"></td><td><pre> <span class="token comment">-- 说明：spark 读取文件时，默认是采用 hadoop 读取文件的规则，按行读取。</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 环境准备和连接 Spark</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> sparkConf<span class="token operator">:</span> SparkConf <span class="token operator">=</span> <span class="token keyword">new</span> SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setMaster<span class="token punctuation">(</span><span class="token string">"local"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setAppName<span class="token punctuation">(</span><span class="token string">"wordCount"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> SparkContext<span class="token punctuation">(</span>sparkConf<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">// 创建 RDD</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token comment">// 将 RDD 处理后的数据保存到分区文件中</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    rdd<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h4 id="552-并行度与分区"><a class="anchor" href="#552-并行度与分区">#</a> 5.5.2 并行度与分区</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 1. 理解一下什么是并行度和分区</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   并行度：parallelism，指整个集群同时执行任务的数量</pre></td></tr><tr><td data-num="3"></td><td><pre>   分区：partitions，数据在RDD中分区，在RDD模型中，一个分区将生成一个task，且task执行互不影响。</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">-- 2. 并行度和分区的关系</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   默认情况下（即资源充足的情况下），一个分区生成的一个task，一个task为一个并行度。</pre></td></tr><tr><td data-num="7"></td><td><pre>   也就是：分区数量 <span class="token operator">=</span> 并行度。</pre></td></tr><tr><td data-num="8"></td><td><pre>   </pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">-- 说明：并行度还和集群的总核数有关，所以资源充足就是指集群可用的核数  core >= task 数量，如果可用的 core &lt; task 数量 (即分区数量)，那么并行度就比 task 小。</span></pre></td></tr></table></figure><h5 id="5521-从内存中读取数据"><a class="anchor" href="#5521-从内存中读取数据">#</a> 5.5.2.1 从内存中读取数据</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">1.</span> 创建RDD的方式为：</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token comment">-- 方法 1：parallelize (形参)</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">-- 方法 2：makeRDD (形参)</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">2.</span> 形参为：<span class="token punctuation">(</span> seq:Seq<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">,</span>numSlices：<span class="token keyword">int</span> <span class="token operator">=</span> defaultParallelism<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   形参<span class="token number">2</span>：numSlices：<span class="token keyword">int</span> <span class="token operator">=</span> defaultParallelism</pre></td></tr><tr><td data-num="7"></td><td><pre>   <span class="token string">"参数的含义"</span>：表示集合被切分分区数量，有默认值： number <span class="token keyword">of</span> partitions <span class="token keyword">to</span> divide the collection <span class="token keyword">into</span>。</pre></td></tr><tr><td data-num="8"></td><td><pre>       分区数量：</pre></td></tr><tr><td data-num="9"></td><td><pre>       a、如果传参数了，那么按照传递的参数为分区数量；</pre></td></tr><tr><td data-num="10"></td><td><pre>       b、如果没有传参数，则使用默认值，默认值的情况如下：</pre></td></tr><tr><td data-num="11"></td><td><pre>          源码中：</pre></td></tr><tr><td data-num="12"></td><td><pre>          默认值：defaultParallelism，<span class="token string">"默认并行度"</span>，调用下面这个函数：</pre></td></tr><tr><td data-num="13"></td><td><pre>          scheduler<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>getInt<span class="token punctuation">(</span><span class="token string">"spark.default.parallelism"</span><span class="token punctuation">,</span> totalCores<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>           ①如果连接spark的配置中设定spark<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">.</span>parallelism参数了，那么就等于设定的参数</pre></td></tr><tr><td data-num="15"></td><td><pre>           ②如果没有设置，那么就等于机器总核数</pre></td></tr><tr><td data-num="16"></td><td><pre>               <span class="token string">"什么是机器总核数?"</span></pre></td></tr><tr><td data-num="17"></td><td><pre>               机器总核数 <span class="token operator">=</span> 当前环境中可用核数</pre></td></tr><tr><td data-num="18"></td><td><pre>               <span class="token keyword">local</span> <span class="token operator">=</span><span class="token operator">></span> 单核（单线程）<span class="token operator">=</span><span class="token operator">></span> <span class="token number">1</span></pre></td></tr><tr><td data-num="19"></td><td><pre>               <span class="token keyword">local</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">4</span>核（<span class="token number">4</span>个线程） <span class="token operator">=</span><span class="token operator">></span> <span class="token number">4</span></pre></td></tr><tr><td data-num="20"></td><td><pre>               <span class="token keyword">local</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> 最大核数 <span class="token operator">=</span><span class="token operator">></span> 我的电脑最大核数为<span class="token number">12</span></pre></td></tr><tr><td data-num="21"></td><td><pre>                </pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token number">3.</span> 通过参数<span class="token number">2</span>知道了数据的分区数量，那么数据进入不同分区的规则是什么？</pre></td></tr><tr><td data-num="23"></td><td><pre>   如下有三个案例，通过设置不同的分区数量，确认数据在分区中的情况。</pre></td></tr><tr><td data-num="24"></td><td><pre>   </pre></td></tr><tr><td data-num="25"></td><td><pre>   <span class="token comment">-- 规则总结：</span></pre></td></tr><tr><td data-num="26"></td><td><pre>   内存中的数据在分区中基本上是平均分配的。</pre></td></tr><tr><td data-num="27"></td><td><pre>   如果：数据条数 <span class="token operator">%</span> 分区数 <span class="token operator">=</span><span class="token operator">=</span> <span class="token number">0</span>   <span class="token comment">--> 平均分配，如有 4 个数据，2 个分区，则前面两个数据进入分区 0，后面两个数据进入分区 1</span></pre></td></tr><tr><td data-num="28"></td><td><pre>         数据条数 <span class="token operator">%</span> 分区数 <span class="token operator">!=</span><span class="token number">0</span>   <span class="token comment">--> 会采用一种基本算法实现分配，源码中具体的实现方法如下</span></pre></td></tr><tr><td data-num="29"></td><td><pre>   </pre></td></tr><tr><td data-num="30"></td><td><pre>   </pre></td></tr><tr><td data-num="31"></td><td><pre>       <span class="token comment">-- 计算每个分区中数据的起止索引</span></pre></td></tr><tr><td data-num="32"></td><td><pre>     def positions<span class="token punctuation">(</span>length: Long<span class="token punctuation">,</span> numSlices: <span class="token keyword">Int</span><span class="token punctuation">)</span>: Iterator<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">Int</span><span class="token punctuation">,</span> <span class="token keyword">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> &#123;</pre></td></tr><tr><td data-num="33"></td><td><pre>      <span class="token punctuation">(</span><span class="token number">0</span> until numSlices<span class="token punctuation">)</span><span class="token punctuation">.</span>iterator<span class="token punctuation">.</span>map &#123; i <span class="token operator">=</span><span class="token operator">></span></pre></td></tr><tr><td data-num="34"></td><td><pre>        val <span class="token keyword">start</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">*</span> length<span class="token punctuation">)</span> <span class="token operator">/</span> numSlices<span class="token punctuation">)</span><span class="token punctuation">.</span>toInt</pre></td></tr><tr><td data-num="35"></td><td><pre>        val <span class="token keyword">end</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> length<span class="token punctuation">)</span> <span class="token operator">/</span> numSlices<span class="token punctuation">)</span><span class="token punctuation">.</span>toInt</pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token punctuation">(</span><span class="token keyword">start</span><span class="token punctuation">,</span> <span class="token keyword">end</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="37"></td><td><pre>      &#125;</pre></td></tr><tr><td data-num="38"></td><td><pre>    &#125;</pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token comment">-- Seq 表示内存中的集合</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        seq <span class="token keyword">match</span> &#123;</pre></td></tr><tr><td data-num="41"></td><td><pre>        <span class="token keyword">case</span> _ <span class="token operator">=</span><span class="token operator">></span></pre></td></tr><tr><td data-num="42"></td><td><pre>        val array <span class="token operator">=</span> seq<span class="token punctuation">.</span>toArray  <span class="token comment">-- 将集合中的元素转换为数组</span></pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token comment">-- 调用了上面的计算分区索引的方法</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        positions<span class="token punctuation">(</span>array<span class="token punctuation">.</span>length<span class="token punctuation">,</span> numSlices<span class="token punctuation">)</span><span class="token punctuation">.</span>map &#123; <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token keyword">start</span><span class="token punctuation">,</span> <span class="token keyword">end</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span></pre></td></tr><tr><td data-num="45"></td><td><pre>            array<span class="token punctuation">.</span>slice<span class="token punctuation">(</span><span class="token keyword">start</span><span class="token punctuation">,</span> <span class="token keyword">end</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toSeq  <span class="token comment">-- 根据索引位置对数据进行切分，确定哪些数据进入哪个分区 </span></pre></td></tr><tr><td data-num="46"></td><td><pre>        &#125;<span class="token punctuation">.</span>toSeq</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 情况 1：从内存中读取数据时，集群的并行度、分区及数据进入分区的规则</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">// 创建 spark 环境和连接 spark</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> sparkConf<span class="token operator">:</span> SparkConf <span class="token operator">=</span> <span class="token keyword">new</span> SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setAppName<span class="token punctuation">(</span><span class="token string">"wordcount"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">val</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> SparkContext<span class="token punctuation">(</span>sparkConf<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">// 准备数据</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">/*</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    情况 1：设定分区为 2。</pre></td></tr><tr><td data-num="11"></td><td><pre>    解析结果文件：</pre></td></tr><tr><td data-num="12"></td><td><pre>    1. 生成两个分区文件</pre></td></tr><tr><td data-num="13"></td><td><pre>    2. 分区数据如下：</pre></td></tr><tr><td data-num="14"></td><td><pre>       分区 0：1 2</pre></td></tr><tr><td data-num="15"></td><td><pre>       分区 1：3 4</pre></td></tr><tr><td data-num="16"></td><td><pre>     */</pre></td></tr><tr><td data-num="17"></td><td><pre> <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre> rdd1<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output1"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">/*</span></pre></td></tr><tr><td data-num="21"></td><td><pre>   情况 2：设定分区为 4。</pre></td></tr><tr><td data-num="22"></td><td><pre>   解析结果文件：</pre></td></tr><tr><td data-num="23"></td><td><pre>   1. 生成 4 个分区文件</pre></td></tr><tr><td data-num="24"></td><td><pre>   2. 分区数据如下：</pre></td></tr><tr><td data-num="25"></td><td><pre>      分区 0：1</pre></td></tr><tr><td data-num="26"></td><td><pre>      分区 1：2</pre></td></tr><tr><td data-num="27"></td><td><pre>      分区 2：3</pre></td></tr><tr><td data-num="28"></td><td><pre>      分区 3：4</pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>    */</pre></td></tr><tr><td data-num="31"></td><td><pre>  <span class="token keyword">val</span> rdd2<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="32"></td><td><pre>  rdd1<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output2"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre>    <span class="token comment">/*</span></pre></td></tr><tr><td data-num="35"></td><td><pre>      情况 3：设定分区为 3。</pre></td></tr><tr><td data-num="36"></td><td><pre>      解析结果文件：</pre></td></tr><tr><td data-num="37"></td><td><pre>      1. 生成 3 个分区文件</pre></td></tr><tr><td data-num="38"></td><td><pre>      2. 分区数据如下：</pre></td></tr><tr><td data-num="39"></td><td><pre>         分区 0：1</pre></td></tr><tr><td data-num="40"></td><td><pre>         分区 1：2</pre></td></tr><tr><td data-num="41"></td><td><pre>         分区 2：3 4       </pre></td></tr><tr><td data-num="42"></td><td><pre>       */</pre></td></tr><tr><td data-num="43"></td><td><pre>    <span class="token keyword">val</span> rdd3<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="44"></td><td><pre>    rdd1<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output3"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="5522-从文件中读取数据"><a class="anchor" href="#5522-从文件中读取数据">#</a> 5.5.2.2 从文件中读取数据</h5><ol><li>单文件读取情况</li></ol><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 问题 1：分区数如何确定：</span></pre></td></tr><tr><td data-num="2"></td><td><pre>   </pre></td></tr><tr><td data-num="3"></td><td><pre>   方法解读：textFile<span class="token punctuation">(</span>path:String<span class="token punctuation">,</span>minPartitions：<span class="token keyword">Int</span> <span class="token operator">=</span> defaultMinPartitions<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>   </pre></td></tr><tr><td data-num="5"></td><td><pre>   <span class="token comment">--1. 建议最小分区数：</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    参数<span class="token number">2</span>：minPartitions：<span class="token keyword">Int</span> <span class="token operator">=</span> defaultMinPartitions，指建议产生的RDD的最小分区数，有默认值</pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">--2. 情况一：假如使用默认值："取 defaultParallelism【默认并行度】和 2 的最小值"</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        默认值：defaultMinPartitions，源码中调用了如下方法：<span class="token string">"取defaultParallelism【默认并行度】和2的最小值"</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        源码：def defaultMinPartitions: <span class="token keyword">Int</span> <span class="token operator">=</span> math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>defaultParallelism<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>         defaultParallelism：源码中调用：</pre></td></tr><tr><td data-num="12"></td><td><pre>         scheduler<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>getInt<span class="token punctuation">(</span><span class="token string">"spark.default.parallelism"</span><span class="token punctuation">,</span> totalCores<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>         ①如果连接spark的配置中设定spark<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">.</span>parallelism参数了，那么就等于设定的参数</pre></td></tr><tr><td data-num="14"></td><td><pre>         ②如果没有设置，那么就等于总核数</pre></td></tr><tr><td data-num="15"></td><td><pre>               <span class="token string">"什么是总核数?"</span></pre></td></tr><tr><td data-num="16"></td><td><pre>               机器总核数 <span class="token operator">=</span> 当前环境中可用核数</pre></td></tr><tr><td data-num="17"></td><td><pre>                <span class="token keyword">local</span> <span class="token operator">=</span><span class="token operator">></span> 单核（单线程）<span class="token operator">=</span><span class="token operator">></span> <span class="token number">1</span></pre></td></tr><tr><td data-num="18"></td><td><pre>                <span class="token keyword">local</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">4</span>核（<span class="token number">4</span>个线程） <span class="token operator">=</span><span class="token operator">></span> <span class="token number">4</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                <span class="token keyword">local</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> 最大核数 <span class="token operator">=</span><span class="token operator">></span> 我的电脑最大核数为<span class="token number">12</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>     <span class="token comment">--3. 情况二：当传递了参数以后：使用传递的参数值。</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>     <span class="token comment">--4. 什么是最小分区数？</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        所谓的最小分区数，取决于总的字节数是否能整除分区数，并且看剩下的字节数<span class="token operator">/</span>每个分区的字节数是否</pre></td></tr><tr><td data-num="25"></td><td><pre>        大于<span class="token number">10</span><span class="token operator">%</span>，如果大于<span class="token number">10</span><span class="token operator">%</span>，则剩余的字节数会生产一个新的分区。</pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>    <span class="token comment">--5. 实际上的分区数是多少呢？</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token number">1.</span> 实际的分区数 <span class="token operator">>=</span> 设定的RDD最小分区数</pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token number">2.</span> 算法：文件的字节数 <span class="token operator">/</span> RDD设定的最小分区数  <span class="token operator">=</span> result</pre></td></tr><tr><td data-num="30"></td><td><pre>       a、如果恰好整除，则实际的分区数<span class="token operator">=</span>设定的RDD最小分区数</pre></td></tr><tr><td data-num="31"></td><td><pre>       b、如果除不尽，有余数，如果余数 <span class="token operator">/</span> result <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token operator">%</span> <span class="token punctuation">,</span>则实际的分区数<span class="token operator">=</span>设定的RDD最小分区数</pre></td></tr><tr><td data-num="32"></td><td><pre>                            如果余数 <span class="token operator">/</span> result <span class="token operator">></span> <span class="token number">10</span><span class="token operator">%</span> <span class="token punctuation">,</span>则实际的分区数<span class="token operator">=</span> 设定的RDD最小分区数 <span class="token operator">+</span> <span class="token number">1</span></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span><span class="token operator">=</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token comment">-- 问题 2：在没有指定分区器的情况下，数据依据什么规则进入不同的分区？</span></pre></td></tr><tr><td data-num="35"></td><td><pre></pre></td></tr><tr><td data-num="36"></td><td><pre>    通过查看源码发现，Spark读取文件采用的是hadoop的读取规则。</pre></td></tr><tr><td data-num="37"></td><td><pre>    <span class="token number">1</span>、切片规则：<span class="token string">"以字节的方式来切分数据"</span></pre></td></tr><tr><td data-num="38"></td><td><pre>    <span class="token number">2</span>、数据读取规则：<span class="token string">"按行读取"</span>。</pre></td></tr><tr><td data-num="39"></td><td><pre></pre></td></tr><tr><td data-num="40"></td><td><pre>    回答问题<span class="token number">2</span>之前，我们先来回答如下两个问题。</pre></td></tr><tr><td data-num="41"></td><td><pre>    问题a：文件到底切成几片<span class="token punctuation">(</span>也就是分区的数量<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="42"></td><td><pre>          按照文件的字节数，确定预计的切片数量。</pre></td></tr><tr><td data-num="43"></td><td><pre></pre></td></tr><tr><td data-num="44"></td><td><pre>    问题b：分区数据是如何进行存储的？</pre></td></tr><tr><td data-num="45"></td><td><pre>        <span class="token number">1.</span>换行符为<span class="token number">2</span>个字节</pre></td></tr><tr><td data-num="46"></td><td><pre>        <span class="token number">2.</span>分区数据按行为单位进行读取，一行的数据不会被拆分。</pre></td></tr><tr><td data-num="47"></td><td><pre></pre></td></tr><tr><td data-num="48"></td><td><pre>    <span class="token string">"规则"</span>：数据进行不同分区的规则有二，二者合并一起使用。</pre></td></tr><tr><td data-num="49"></td><td><pre>    规则一：数据起始偏移量和字节数。</pre></td></tr><tr><td data-num="50"></td><td><pre>    规则二：数据偏移量<span class="token punctuation">(</span><span class="token keyword">offset</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="51"></td><td><pre></pre></td></tr><tr><td data-num="52"></td><td><pre>    <span class="token comment">-- 具体是什么意思？一起跟着下面案例来详细认识。</span></pre></td></tr></table></figure><ul><li>案例 1：</li></ul><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>举例<span class="token number">1</span>：</pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--word1 数据：</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token number">12</span>@@</pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token number">234</span></pre></td></tr><tr><td data-num="5"></td><td><pre>        说明：换行符<span class="token punctuation">(</span>用@@代替<span class="token punctuation">)</span>为<span class="token number">2</span>个字节，Spark是按照行进行读取数据。</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">-- 第一步：建议生成 RDD 的最小分区数： => 2</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">-- 第二步：计算实际的分区数：=> 3</span></pre></td></tr><tr><td data-num="9"></td><td><pre>               <span class="token number">1.</span>计算文件的字节数：<span class="token operator">=</span><span class="token operator">></span> <span class="token number">7</span>个字节</pre></td></tr><tr><td data-num="10"></td><td><pre>               <span class="token number">2.</span>计算整除的结果和余数： <span class="token number">7</span><span class="token operator">/</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">3</span> <span class="token punctuation">.</span><span class="token number">.1</span></pre></td></tr><tr><td data-num="11"></td><td><pre>               <span class="token number">3.</span>计算余数和每个分区字节数的比率：<span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token operator">></span> <span class="token number">10</span><span class="token operator">%</span> <span class="token operator">=</span><span class="token operator">></span> 生成一个新的分区  <span class="token operator">=</span><span class="token operator">></span> <span class="token number">3</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">-- 第三步：计算每个分区的数据起始偏移量和每个分区的字节数</span></pre></td></tr><tr><td data-num="13"></td><td><pre>               分区<span class="token number">0</span>：<span class="token punctuation">(</span>起始偏移量，字节数<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>               分区<span class="token number">1</span>：<span class="token punctuation">(</span>起始偏移量，字节数<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre>               分区<span class="token number">2</span>：<span class="token punctuation">(</span>起始偏移量，字节数<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">-- 第四步：计算每行数据的偏移量</span></pre></td></tr><tr><td data-num="17"></td><td><pre>               <span class="token number">12</span>@@    <span class="token operator">=</span><span class="token operator">></span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span></pre></td></tr><tr><td data-num="18"></td><td><pre>               <span class="token number">234</span>     <span class="token operator">=</span><span class="token operator">></span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">-- 第五步：数据的分配：按行读取，数据只会被读取一次</span></pre></td></tr><tr><td data-num="20"></td><td><pre>               分区<span class="token number">0</span> <span class="token operator">=</span><span class="token operator">></span> 读取索引为<span class="token number">0</span><span class="token operator">/</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token operator">/</span><span class="token number">3</span>的数据，读取<span class="token number">12</span></pre></td></tr><tr><td data-num="21"></td><td><pre>               分区<span class="token number">1</span> <span class="token operator">=</span><span class="token operator">></span> 读取索引为<span class="token number">3</span><span class="token operator">/</span><span class="token number">4</span><span class="token operator">/</span><span class="token number">5</span><span class="token operator">/</span><span class="token number">6</span>的数据，发现<span class="token number">3</span>已经被读取了，所以读取<span class="token number">4</span><span class="token operator">/</span><span class="token number">5</span><span class="token operator">/</span><span class="token number">6</span>索引的数据，读取：<span class="token number">234</span></pre></td></tr><tr><td data-num="22"></td><td><pre>               分区<span class="token number">2</span> <span class="token operator">=</span><span class="token operator">></span> 读取索引为<span class="token number">6</span><span class="token operator">/</span><span class="token number">7</span>的数据<span class="token punctuation">,</span>发现<span class="token number">6</span>已经被读取，索引<span class="token number">7</span>无数据，所以分区<span class="token number">2</span>没有数据。</pre></td></tr><tr><td data-num="23"></td><td><pre>     <span class="token operator">*</span><span class="token operator">/</span></pre></td></tr><tr><td data-num="24"></td><td><pre>     </pre></td></tr><tr><td data-num="25"></td><td><pre>	  	val rdd1: RDD<span class="token punctuation">[</span>String<span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token string">"input/word1"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="26"></td><td><pre>  		rdd1<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>案例 2</li></ul><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>举例<span class="token number">2</span>：</pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--word2 数据：</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        <span class="token number">1</span>@@</pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token number">2</span>@@</pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token number">3</span>@@</pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token number">4</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        说明：换行符<span class="token punctuation">(</span>用@@代替<span class="token punctuation">)</span>为<span class="token number">2</span>个字节，Spark是按照行进行读取数据。</pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">-- 第一步：建议生成 RDD 的最小分区数： => 3</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token comment">-- 第二步：计算实际的分区数：=> 4</span></pre></td></tr><tr><td data-num="11"></td><td><pre>               <span class="token number">1.</span>计算文件的字节数：<span class="token operator">=</span><span class="token operator">></span> <span class="token number">10</span>个字节</pre></td></tr><tr><td data-num="12"></td><td><pre>               <span class="token number">2.</span>计算整除的结果和余数： <span class="token number">10</span><span class="token operator">/</span><span class="token number">3</span><span class="token operator">=</span><span class="token number">3</span> <span class="token punctuation">.</span><span class="token number">.1</span></pre></td></tr><tr><td data-num="13"></td><td><pre>               <span class="token number">3.</span>计算余数和每个分区字节数的比率：<span class="token number">1</span><span class="token operator">/</span><span class="token number">3</span> <span class="token operator">></span> <span class="token number">10</span><span class="token operator">%</span> <span class="token operator">=</span><span class="token operator">></span> 生成一个新的分区</pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">-- 第三步：计算每个分区的数据起始偏移量和每个分区的字节数</span></pre></td></tr><tr><td data-num="15"></td><td><pre>               分区<span class="token number">0</span>：<span class="token punctuation">(</span>起始偏移量，字节数<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>               分区<span class="token number">1</span>：<span class="token punctuation">(</span>起始偏移量，字节数<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>               分区<span class="token number">2</span>：<span class="token punctuation">(</span>起始偏移量，字节数<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>               分区<span class="token number">3</span>：<span class="token punctuation">(</span>起始偏移量，字节数<span class="token punctuation">)</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">-- 第四步：计算数据的偏移量</span></pre></td></tr><tr><td data-num="20"></td><td><pre>               <span class="token number">1</span>@@  <span class="token operator">=</span><span class="token operator">></span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span></pre></td></tr><tr><td data-num="21"></td><td><pre>               <span class="token number">2</span>@@  <span class="token operator">=</span><span class="token operator">></span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span></pre></td></tr><tr><td data-num="22"></td><td><pre>               <span class="token number">3</span>@@  <span class="token operator">=</span><span class="token operator">></span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span></pre></td></tr><tr><td data-num="23"></td><td><pre>               <span class="token number">4</span>    <span class="token operator">=</span><span class="token operator">></span> <span class="token number">9</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token comment">-- 第五步：数据的分配：按行读取，数据只会被读取一次</span></pre></td></tr><tr><td data-num="25"></td><td><pre>               分区<span class="token number">0</span> <span class="token operator">=</span><span class="token operator">></span> 读取索引为<span class="token number">0</span><span class="token operator">/</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token operator">/</span><span class="token number">3</span>的数据，因为第一行数据不够，所以第二行也被读取，</pre></td></tr><tr><td data-num="26"></td><td><pre>                       所以实际读取了索引为<span class="token number">0</span><span class="token operator">/</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">2</span><span class="token operator">/</span><span class="token number">3</span><span class="token operator">/</span><span class="token number">4</span><span class="token operator">/</span><span class="token number">5</span>的数据，读取<span class="token number">1</span> <span class="token number">2</span></pre></td></tr><tr><td data-num="27"></td><td><pre>               分区<span class="token number">1</span> <span class="token operator">=</span><span class="token operator">></span> 读取索引为<span class="token number">3</span><span class="token operator">/</span><span class="token number">4</span><span class="token operator">/</span><span class="token number">5</span><span class="token operator">/</span><span class="token number">6</span>的数据，发现<span class="token number">3</span><span class="token operator">/</span><span class="token number">4</span><span class="token operator">/</span><span class="token number">5</span>已经被读取了，所以只能读取索引为<span class="token number">6</span>的数据，</pre></td></tr><tr><td data-num="28"></td><td><pre>                        所以读取<span class="token number">6</span>索引所在行，最后读取了索引为<span class="token number">6</span><span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span><span class="token number">8</span>的数据，读取：<span class="token number">3</span></pre></td></tr><tr><td data-num="29"></td><td><pre>               分区<span class="token number">2</span> <span class="token operator">=</span><span class="token operator">></span> 读取索引为<span class="token number">6</span><span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span><span class="token number">8</span><span class="token operator">/</span><span class="token number">9</span>的数据<span class="token punctuation">,</span>发现<span class="token number">6</span><span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span><span class="token number">8</span>已经被读取，所以只能读取索引为<span class="token number">9</span>的数据，</pre></td></tr><tr><td data-num="30"></td><td><pre>                        所以读取索引<span class="token number">9</span>所在行，最后读取了索引为<span class="token number">9</span>的数据，读取：<span class="token number">4</span>。</pre></td></tr><tr><td data-num="31"></td><td><pre>               分区<span class="token number">3</span> <span class="token operator">=</span><span class="token operator">></span>  读取索引为<span class="token number">9</span><span class="token operator">/</span><span class="token number">10</span>的数据<span class="token punctuation">,</span>发现<span class="token number">9</span>已经被读取，索引<span class="token number">10</span>无数据，所以分区<span class="token number">2</span>没有数据。</pre></td></tr><tr><td data-num="32"></td><td><pre>    </pre></td></tr><tr><td data-num="33"></td><td><pre></pre></td></tr><tr><td data-num="34"></td><td><pre>    val rdd2: RDD<span class="token punctuation">[</span>String<span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token string">"input/word2"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    rdd2<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ol start="2"><li>多文件读取情况</li></ol><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>多文件和单文件异同：</pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token number">1</span><span class="token punctuation">)</span> 字节数为递归计算所有文件的字节数总和</pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token number">2</span>）不能跨文件读取数据</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token number">3</span>）依然是按行读取</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token number">4</span>）计算每个分区的字节数的算法保持不变，</pre></td></tr><tr><td data-num="6"></td><td><pre>       但是总分区数增加的个数依据每个文件的字节数是否能整除每个分区的字节数而定。</pre></td></tr></table></figure><ul><li>案例解析</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">object</span> Spark_FliePartitions <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Unit</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">val</span> sparkConf<span class="token operator">:</span> SparkConf <span class="token operator">=</span> <span class="token keyword">new</span> SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setAppName<span class="token punctuation">(</span><span class="token string">"FileParallelism"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">val</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> SparkContext<span class="token punctuation">(</span>sparkConf<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">/*</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    文件 1：</pre></td></tr><tr><td data-num="9"></td><td><pre>    12@@  => 0,1,2,3</pre></td></tr><tr><td data-num="10"></td><td><pre>    234   => 4,5,6</pre></td></tr><tr><td data-num="11"></td><td><pre>    文件 2：</pre></td></tr><tr><td data-num="12"></td><td><pre>    1@@   => 0,1,2</pre></td></tr><tr><td data-num="13"></td><td><pre>    2@@   => 3,4,5</pre></td></tr><tr><td data-num="14"></td><td><pre>    3@@   => 6,7,8</pre></td></tr><tr><td data-num="15"></td><td><pre>    4     => 9</pre></td></tr><tr><td data-num="16"></td><td><pre>    计算过程：</pre></td></tr><tr><td data-num="17"></td><td><pre>    1. 字节总数：7+10=17</pre></td></tr><tr><td data-num="18"></td><td><pre>    2. 每个分区字节数：17/3=5 .. 2</pre></td></tr><tr><td data-num="19"></td><td><pre>    3. 文件 1：</pre></td></tr><tr><td data-num="20"></td><td><pre>       分区 0：(0,5) =>12 234</pre></td></tr><tr><td data-num="21"></td><td><pre>       分区 1：(5,7) => 空</pre></td></tr><tr><td data-num="22"></td><td><pre>     文件 2：</pre></td></tr><tr><td data-num="23"></td><td><pre>       分区 0：(0,5)  =>1 2</pre></td></tr><tr><td data-num="24"></td><td><pre>       分区 1：(5,10) => 3 4</pre></td></tr><tr><td data-num="25"></td><td><pre>     */</pre></td></tr><tr><td data-num="26"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    rdd<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    sc<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h4 id="553-rdd算子"><a class="anchor" href="#553-rdd算子">#</a> 5.5.3 RDD 算子</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>RDD转换算子：</pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">-- 1. 什么是算子？</span></pre></td></tr><tr><td data-num="3"></td><td><pre>       认知心理学，解决问题的思路，也就是方法。</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">-- 2. 所谓的 RDD 算子，其实就是将旧的 RDD 通过方法的调用转换为新的 RDD</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">-- 3. 既然算子也是方法，那么为什么叫做算子呢？</span></pre></td></tr><tr><td data-num="6"></td><td><pre>          算子是RDD所拥有的，RDD只是封装逻辑，由Driver将task分配给Executor执行，所以是分布式计算的逻辑。</pre></td></tr><tr><td data-num="7"></td><td><pre>          方法：则是在当前的虚拟机中执行。</pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">-- 4. 算子的分类：</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      根据RDD处理数据的方式不同分为：<span class="token keyword">value</span>类型、双<span class="token keyword">value</span>类型、<span class="token keyword">key</span><span class="token operator">-</span><span class="token keyword">value</span>类型。</pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token keyword">value</span>：单值数据，如List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      双<span class="token keyword">value</span>:指多个RDD之间的运算</pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token keyword">key</span><span class="token operator">-</span><span class="token keyword">value</span>:指数据结构是kv键值对。List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      </pre></td></tr><tr><td data-num="14"></td><td><pre>      那么为什么要这么设计呢？</pre></td></tr><tr><td data-num="15"></td><td><pre>      因为不同的数据结构，处理数据的需要不一样，也就有对应的算子来应对。</pre></td></tr></table></figure><h5 id="5531-map"><a class="anchor" href="#5531-map">#</a> 5.5.3.1 map</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 算子：map (形参)：</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token number">1.</span> 作用：将处理的数据逐条进行映射处理，<span class="token string">"类比scala中的map，对数据进行结构转换"</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token number">2.</span> 形参：def map<span class="token punctuation">[</span>U: ClassTag<span class="token punctuation">]</span><span class="token punctuation">(</span>f: T <span class="token operator">=</span><span class="token operator">></span> U<span class="token punctuation">)</span>: RDD<span class="token punctuation">[</span>U<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token number">3.</span> 基本使用如下：</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rddmap<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    println<span class="token punctuation">(</span>rddmap<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 关于 map 算子的两个问题</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">-- 问题 1：分区的问题：RDD 有分区列表，每个 RDD 都有相同的分区计算函数，那么新的 RDD 与旧的 RDD 的分区关系是什么？</span></pre></td></tr><tr><td data-num="4"></td><td><pre>          默认分区的数量保持不变，数据会转换后输出。</pre></td></tr><tr><td data-num="5"></td><td><pre>   </pre></td></tr><tr><td data-num="6"></td><td><pre>   <span class="token comment">-- 问题 2：Map 中数据处理的顺序是怎么样的？</span></pre></td></tr><tr><td data-num="7"></td><td><pre>          通过如下验证发现：</pre></td></tr><tr><td data-num="8"></td><td><pre>          a、分区内数据按照顺序依次执行，且第一条数据的所有逻辑执行完成以后再执行第二条数据，依次类推</pre></td></tr><tr><td data-num="9"></td><td><pre>          b、分区间的数据执行是没有顺序，而且无需等待，即分区间执行逻辑互不影响，各自执行各自的逻辑。</pre></td></tr></table></figure><ul><li>验证如下：</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 测试：新旧 RDD 分区的关系 </span></pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>   <span class="token keyword">val</span> rddmap1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>map<span class="token punctuation">(</span> num <span class="token keyword">=></span> num <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token comment">// 将数据输出到本地文件中，查看分区数量及分区内的数据</span></pre></td></tr><tr><td data-num="5"></td><td><pre>   rdd1<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output1"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>   rddmap1<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">// 测试：分区间的执行顺序</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">val</span> rddmap2<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>map<span class="token punctuation">(</span> num <span class="token keyword">=></span> <span class="token punctuation">&#123;</span>println<span class="token punctuation">(</span><span class="token string">"mapA ->"</span> <span class="token operator">+</span> num <span class="token punctuation">)</span><span class="token punctuation">;</span>num <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>  </pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">val</span> rddmap3<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Unit</span><span class="token punctuation">]</span> <span class="token operator">=</span> rddmap1<span class="token punctuation">.</span>map<span class="token punctuation">(</span>num <span class="token keyword">=></span> println<span class="token punctuation">(</span><span class="token string">"mapB ->"</span> <span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token comment">//collect 方法不会转换 RDD，会触发作业的执行，所以将 collect 这样的方法称之为行动（action）算子	</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	rddmap3<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>练习：</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 练习：从服务器日志数据 apache.log 中获取用户请求 URL 资源路径</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token string">"input/apache.log"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> result<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>map<span class="token punctuation">(</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      str <span class="token keyword">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>          <span class="token comment">// 按照空格拆分一条数据</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">val</span> array<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> str<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>          <span class="token comment">// 只取 URL 资源数据</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        array<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token comment">// 遍历结果集</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    result<span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="5532-mappartitions"><a class="anchor" href="#5532-mappartitions">#</a> 5.5.3.2 mapPartitions</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--map () 算子问题：</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  在分区内每次只能获取一个数据，而且只有当前一个数据的所有逻辑执行完成以后才会执行下一个数据，这样一来，效率就相对比较慢。</pre></td></tr><tr><td data-num="3"></td><td><pre>  </pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">-- 引出了另外一个算子:mapPartitions (形参)</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>     <span class="token comment">--1. 形参：(f: Iterator [T] => Iterator [U],preservesPartitioning: Boolean = false): RDD [U]</span></pre></td></tr><tr><td data-num="7"></td><td><pre>           形参<span class="token number">1</span>：f: Iterator<span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token operator">=</span><span class="token operator">></span> Iterator<span class="token punctuation">[</span>U<span class="token punctuation">]</span>，是一个函数</pre></td></tr><tr><td data-num="8"></td><td><pre>                 函数的形参：一个迭代器，内容为一个分区中所有的数据；</pre></td></tr><tr><td data-num="9"></td><td><pre>                 函数的返回：分区内数据经过转换以后数据形成的<span class="token string">"迭代器"</span>。</pre></td></tr><tr><td data-num="10"></td><td><pre>           参数<span class="token number">2</span>：暂时不管。</pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">--2. 返回结果：返回一个新的 RDD</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">--3. 算子的作用：</span></pre></td></tr><tr><td data-num="13"></td><td><pre>           将待处理的数据以分区为单位发送到计算节点进行处理，这里的处理是指可以进行<span class="token string">"任意的处理"</span>，哪怕是过滤数据   </pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">--4. 与 map () 算子的不同点：</span></pre></td></tr><tr><td data-num="15"></td><td><pre>           map 算子是一个全量数据处理，不能丢失数据；</pre></td></tr><tr><td data-num="16"></td><td><pre>           mapPartitions 算子一次获取分区中所有的数据，那么可以执行迭代器所有的操作，如可以进行数据的过滤。</pre></td></tr><tr><td data-num="17"></td><td><pre>   <span class="token comment">--5. mapPartitions 算子存在的问题</span></pre></td></tr><tr><td data-num="18"></td><td><pre>          如果一个分区的数据没有处理完，那么该分区内所有的数据都不会释放，即使是前面已经处理完的数据也不会释放，</pre></td></tr><tr><td data-num="19"></td><td><pre>          容易出现内存溢出。 </pre></td></tr><tr><td data-num="20"></td><td><pre>   <span class="token comment">--6. map 和 mapPartitions () 算子的选择：</span></pre></td></tr><tr><td data-num="21"></td><td><pre>      	  如果内存空间足够大，为了提高效率时，推荐使用mapPartitions<span class="token punctuation">(</span><span class="token punctuation">)</span>算子</pre></td></tr></table></figure><ul><li>代码演示</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>mapPartitions<span class="token punctuation">(</span>iter <span class="token keyword">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token comment">// 只要分区内为偶数的数据</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      iter<span class="token punctuation">.</span>filter<span class="token punctuation">(</span>_<span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>练习</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 练习：获取每个数据分区的最大值</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">val</span> result<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>mapPartitions<span class="token punctuation">(</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      iter <span class="token keyword">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token comment">// 求分区内的最大值，返回值为一个值，不是迭代器，所以使用 List 集合进行包装</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        List<span class="token punctuation">(</span>iter<span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">.</span>iterator</pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    println<span class="token punctuation">(</span>result<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="5533-mappartitionswithindex"><a class="anchor" href="#5533-mappartitionswithindex">#</a> 5.5.3.3 mapPartitionsWithIndex</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：mapPartitionsWithIndex (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">--2. 形参：(f: (Int, Iterator [T]) => Iterator [U],preservesPartitioning: Boolean = false)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>       形参<span class="token number">1</span>：f: <span class="token punctuation">(</span><span class="token keyword">Int</span><span class="token punctuation">,</span> Iterator<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> Iterator<span class="token punctuation">[</span>U<span class="token punctuation">]</span>，是一个函数</pre></td></tr><tr><td data-num="5"></td><td><pre>                函数的形参：</pre></td></tr><tr><td data-num="6"></td><td><pre>                参数<span class="token number">1</span>：为分区号</pre></td></tr><tr><td data-num="7"></td><td><pre>                参数<span class="token number">2</span>：为一个迭代器，内容为一个分区中所有的数据；</pre></td></tr><tr><td data-num="8"></td><td><pre>                函数的返回：分区内每个数据经过转换以后数据形成的<span class="token string">"迭代器"</span>。</pre></td></tr><tr><td data-num="9"></td><td><pre>      形参<span class="token number">2</span>：暂时不管。</pre></td></tr><tr><td data-num="10"></td><td><pre>      </pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">--3. 算子的作用：将待处理的数据以分区为单位发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据，</span></pre></td></tr><tr><td data-num="12"></td><td><pre>        <span class="token string">"在处理时同时可以获取当前分区索引"</span></pre></td></tr></table></figure><ul><li>代码演示</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 获取每个分区最大值以及分区号</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>mapPartitionsWithIndex<span class="token punctuation">(</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      <span class="token punctuation">(</span>num<span class="token punctuation">,</span> iter<span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        List<span class="token punctuation">(</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> iter<span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>iterator</pre></td></tr><tr><td data-num="7"></td><td><pre>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>练习</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 练习：获取第二个数据分区的数据    </span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">=</span> rdd<span class="token punctuation">.</span>mapPartitionsWithIndex<span class="token punctuation">(</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      <span class="token punctuation">(</span>num<span class="token punctuation">,</span> iter<span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>          iter</pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>          Nil<span class="token punctuation">.</span>iterator</pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="5534-flatmap"><a class="anchor" href="#5534-flatmap">#</a> 5.5.3.4 flatmap</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：flatMap (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token comment">--2. 形参：(f: T => TraversableOnce [U]): 是一个函数</span></pre></td></tr><tr><td data-num="4"></td><td><pre>           函数的参数：分区内的一个一个的元素</pre></td></tr><tr><td data-num="5"></td><td><pre>           返回值：经过映射以后将数据进行扁平化，返回一个可迭代的集合</pre></td></tr><tr><td data-num="6"></td><td><pre>     </pre></td></tr><tr><td data-num="7"></td><td><pre>     <span class="token comment">--3. 作用：和 scala 中的作用完全一致，映射扁平</span></pre></td></tr></table></figure><ul><li>代码演示</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>List<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span>List<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span>list<span class="token keyword">=></span>list<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>练习</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 将 List (List (1,2),3,List (4,5)) 进行扁平化操作</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> List<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      data <span class="token keyword">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        data <span class="token keyword">match</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>          <span class="token keyword">case</span> list<span class="token operator">:</span> List<span class="token punctuation">[</span>_<span class="token punctuation">]</span> <span class="token keyword">=></span> list</pre></td></tr><tr><td data-num="8"></td><td><pre>          <span class="token keyword">case</span> b <span class="token keyword">=></span> List<span class="token punctuation">(</span>b<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="5535-glom"><a class="anchor" href="#5535-glom">#</a> 5.5.3.5 glom</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：glom (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>      <span class="token comment">--2. 形参：空，无形参</span></pre></td></tr><tr><td data-num="3"></td><td><pre>      <span class="token comment">--3. 返回值：RDD [Array [T]]，返回一个一个的数组，数组的数据来自同一个分区</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      <span class="token comment">--4. 作用：将同一个分区内的数据转换成数组。</span></pre></td></tr></table></figure><ul><li>代码实现</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span>Array<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>glom<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>array<span class="token keyword">=></span><span class="token punctuation">&#123;</span>println<span class="token punctuation">(</span>array<span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>练习</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 求每个分区的最大值的和</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 方法 1：以分区来单位，进行处理</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">val</span> sum<span class="token operator">:</span> <span class="token builtin">Double</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>mapPartitions<span class="token punctuation">(</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      iter <span class="token keyword">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        List<span class="token punctuation">(</span>iter<span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">.</span>iterator</pre></td></tr><tr><td data-num="8"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    println<span class="token punctuation">(</span>sum<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 方法 2：使用 glom</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    println<span class="token punctuation">(</span>rdd<span class="token punctuation">.</span>glom<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span>array <span class="token keyword">=></span> List<span class="token punctuation">(</span>array<span class="token punctuation">.</span>max<span class="token punctuation">)</span><span class="token punctuation">.</span>iterator<span class="token punctuation">)</span><span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="5536-groupby"><a class="anchor" href="#5536-groupby">#</a> 5.5.3.6 groupBy</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：groupBy (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>     <span class="token comment">--2. 形参：def groupBy [K](f: T => K,p:Partitioner)(implicit kt: ClassTag [K]): RDD [(K, Iterable [T])]</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            形参<span class="token number">1</span>：f: T <span class="token operator">=</span><span class="token operator">></span> K：是一个函数</pre></td></tr><tr><td data-num="4"></td><td><pre>                  函数的形参为：数据集中的一个一个的元素</pre></td></tr><tr><td data-num="5"></td><td><pre>                  返回值为：返回分组的K</pre></td></tr><tr><td data-num="6"></td><td><pre>            形参<span class="token number">2</span>：p:Partitioner<span class="token punctuation">,</span>指设定下游的分区数量，如果不设置，则默认为旧RDD的分区数量</pre></td></tr><tr><td data-num="7"></td><td><pre>     <span class="token comment">--3. 算子的返回值：返回一个元组</span></pre></td></tr><tr><td data-num="8"></td><td><pre>           元组的第一个元素：表示分组的<span class="token keyword">Key</span></pre></td></tr><tr><td data-num="9"></td><td><pre>           元组的第二个元素：表示相同的<span class="token keyword">key</span>形成可迭代的集合</pre></td></tr><tr><td data-num="10"></td><td><pre>     <span class="token comment">--4. 作用：将数据根据指定的规则进行分组。</span></pre></td></tr><tr><td data-num="11"></td><td><pre>     <span class="token comment">--5. 特点：</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            a、分区默认不变</pre></td></tr><tr><td data-num="13"></td><td><pre>            b、不同分区的数据会被重新打乱进入到不同的分区中；</pre></td></tr><tr><td data-num="14"></td><td><pre>            c、我们将上游的分区数据打乱重新组合到下游的分区中，这个操作称之为shuffle</pre></td></tr><tr><td data-num="15"></td><td><pre>            d、极限情况下，所有的数据会被分到一个分区</pre></td></tr><tr><td data-num="16"></td><td><pre>            e、一个组的数据在一个分区，但是并不是说一个分区中只有一个组，</pre></td></tr><tr><td data-num="17"></td><td><pre>               <span class="token string">"如当分组数量大于分区数量时，那么一个分区就可能有多个组"</span>。</pre></td></tr><tr><td data-num="18"></td><td><pre>     <span class="token comment">--6. 存在的问题：    </span></pre></td></tr><tr><td data-num="19"></td><td><pre>       	    groupby方法会导致数据重新组合以后不均匀</pre></td></tr><tr><td data-num="20"></td><td><pre>     <span class="token comment">--7. 解决方案：</span></pre></td></tr><tr><td data-num="21"></td><td><pre>            通过传递参数，改变下游分区的数量。</pre></td></tr></table></figure><p>![image-20200606000907169](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200606000907.png)</p><ul><li>代码</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num="2"></td><td><pre>     1. 一个组的数据在一个分区，但是并不是说一个分区中只有一个组</pre></td></tr><tr><td data-num="3"></td><td><pre>     奇偶分组，将数据分成两个组，结果文件中只有一个分区文件，分区文件中有两个分组。</pre></td></tr><tr><td data-num="4"></td><td><pre>      */</pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> Iterable<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>_ <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    rdd1<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">/*</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    2. 当前有 4 个分区，奇偶分组只会有两个分组，所以结果文件中有 4 个分区文件，但是有两个分区分件中没有数据</pre></td></tr><tr><td data-num="13"></td><td><pre>     */</pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> Iterable<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>_ <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    rdd1<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">/*</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    3. 通过设置下游的分区数量解决分区无数据的情况，此时生成的结果文件只有两个分区</pre></td></tr><tr><td data-num="22"></td><td><pre>     */</pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> Iterable<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>num <span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token keyword">=></span> num <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        rdd1<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>练习</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//    小功能：将 List ("Hello", "hive", "hbase", "Hadoop") 根据单词首写字母进行分组。</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"hive"</span><span class="token punctuation">,</span> <span class="token string">"hbase"</span><span class="token punctuation">,</span> <span class="token string">"Hadoop"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> Iterable<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>word <span class="token keyword">=></span> word<span class="token punctuation">.</span>substring<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">//    小功能：从服务器日志数据 apache.log 中获取每个时间段访问量。</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token string">"input/apache.log"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span>str <span class="token keyword">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>      <span class="token keyword">val</span> datas<span class="token operator">:</span> ArrayOps<span class="token punctuation">.</span>ofRef<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> str<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      List<span class="token punctuation">(</span>datas<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>substring<span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token keyword">val</span> rdd2<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> Iterable<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>time<span class="token keyword">=></span>time<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    println<span class="token punctuation">(</span>rdd2<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span>data <span class="token keyword">=></span> List<span class="token punctuation">(</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>_1<span class="token punctuation">,</span> data<span class="token punctuation">.</span>_2<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>sortBy<span class="token punctuation">(</span>_<span class="token punctuation">.</span>_1<span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token comment">//    小功能：WordCount。</span></pre></td></tr><tr><td data-num="17"></td><td><pre>      <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token string">"input/word1"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>      <span class="token keyword">val</span> wordcount<span class="token operator">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span>_<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>word <span class="token keyword">=></span> word<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre>      <span class="token punctuation">.</span>map<span class="token punctuation">(</span>tuple <span class="token keyword">=></span> <span class="token punctuation">(</span>tuple<span class="token punctuation">.</span>_1<span class="token punctuation">,</span> tuple<span class="token punctuation">.</span>_2<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>     println<span class="token punctuation">(</span>wordcount<span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="5537-filter"><a class="anchor" href="#5537-filter">#</a> 5.5.3.7 filter</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：Filter (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：(f: T => Boolean)：是一个函数，用法和 scala 中的 fliter 类似</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            函数的形参：RDD中数据集的一个一个的数据</pre></td></tr><tr><td data-num="4"></td><td><pre>            返回值：ture或者<span class="token boolean">false</span></pre></td></tr><tr><td data-num="5"></td><td><pre>            <span class="token boolean">true</span>：表示数据被保留下来</pre></td></tr><tr><td data-num="6"></td><td><pre>            <span class="token boolean">false</span>：表示数据被过滤掉</pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">--3. 作用：将数据根据指定的规则进行筛选过滤，符合规则的数据保留，不符合规则的数据丢弃。</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">--4. 特点：</span></pre></td></tr><tr><td data-num="9"></td><td><pre>           a、分区不变</pre></td></tr><tr><td data-num="10"></td><td><pre>           b、分区内的数据可能不均衡，生产环境下，可能会导致数据倾斜</pre></td></tr></table></figure><ul><li>代码演示</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>filter<span class="token punctuation">(</span>data <span class="token keyword">=></span> data <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>练习</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 练习：从服务器日志数据 apache.log 中获取 2015 年 5 月 17 日的请求路径</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token string">"input/apache.log"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>map<span class="token punctuation">(</span>data <span class="token keyword">=></span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>data<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">val</span> rdd2<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>filter<span class="token punctuation">(</span>tuple <span class="token keyword">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      tuple<span class="token punctuation">.</span>_1<span class="token punctuation">.</span>substring<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"17/05/2015"</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    rdd2<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="5538-sample"><a class="anchor" href="#5538-sample">#</a> 5.5.3.8 Sample</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：Sample (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参： 有三个参数：</span></pre></td></tr><tr><td data-num="3"></td><td><pre>           参数<span class="token number">1</span>：withReplacement: <span class="token keyword">Boolean</span>，表示数据从原数据集中抽取以后是否还放回</pre></td></tr><tr><td data-num="4"></td><td><pre>           参数<span class="token number">2</span>：fraction: <span class="token keyword">Double</span>：和参数<span class="token number">1</span>配合一起使用，参数<span class="token number">1</span>的值不同，参数<span class="token number">2</span>表示含义不相同。</pre></td></tr><tr><td data-num="5"></td><td><pre>                 情况<span class="token number">1</span>：参数<span class="token number">1</span>为ture，表示抽取以后放回，此时参数<span class="token number">2</span>表示重复抽取的次数</pre></td></tr><tr><td data-num="6"></td><td><pre>                 情况<span class="token number">2</span>：参数<span class="token number">1</span>为<span class="token boolean">false</span>，表示抽取后不放回，此时参数<span class="token number">2</span>表示数据被抽取的几率。</pre></td></tr><tr><td data-num="7"></td><td><pre>                       说明：几率 <span class="token operator">!=</span> 返回数据集数量 <span class="token operator">/</span> 原数据集的数量</pre></td></tr><tr><td data-num="8"></td><td><pre>           参数<span class="token number">3</span>：seed: Long <span class="token operator">=</span> Utils<span class="token punctuation">.</span>random<span class="token punctuation">.</span>nextLong：表示随机数的种子，可以确定数据抽取，可以理解</pre></td></tr><tr><td data-num="9"></td><td><pre>                 为数据的伪随机。所谓的随机是通过某种算法计算得来的，一旦设置了这个参数，每次获取的随机</pre></td></tr><tr><td data-num="10"></td><td><pre>                 数都是固定的。这个参数可选，如果没有设置，那么就是真的随机数，每次返回的结果集都可能是不一样的</pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">--3. 作用：</span></pre></td></tr><tr><td data-num="12"></td><td><pre>          根据指定的规则从数据中抽取数据。</pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">--4. 使用场景：</span></pre></td></tr><tr><td data-num="14"></td><td><pre>          在实际开发中，往往会出现数据倾斜的情况，那么可以从数据倾斜的分区中抽取部分数据，</pre></td></tr><tr><td data-num="15"></td><td><pre>          通过抽取的数据，分析造成数据倾斜的原因。</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//1,7</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">val</span> rdd2<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>sample<span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    println<span class="token punctuation">(</span>rdd2<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//1,1,1,1,3,3,3,3,5,5,6,7,7,8,8,8,8</span></pre></td></tr></table></figure><h5 id="5539-distinct"><a class="anchor" href="#5539-distinct">#</a> 5.5.3.9 distinct</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：distinct (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：有两个重载的方法：</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            方法<span class="token number">1</span>：无参</pre></td></tr><tr><td data-num="4"></td><td><pre>            方法<span class="token number">2</span>：有一个参数：numPartitions: <span class="token keyword">Int</span>:用来改变去重以后的分区数量。</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">--3. 作用：对数据进行去重操作</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>distinct<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    rdd1<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="55310-coalesce"><a class="anchor" href="#55310-coalesce">#</a> 5.5.3.10 coalesce</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：coalesce (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：有三个参数</span></pre></td></tr><tr><td data-num="3"></td><td><pre>           参数<span class="token number">1</span>：numPartitions: <span class="token keyword">Int</span>：重置的分区数量</pre></td></tr><tr><td data-num="4"></td><td><pre>           参数<span class="token number">2</span>：shuffle: <span class="token keyword">Boolean</span> <span class="token operator">=</span> <span class="token boolean">false</span>：是否需要打乱数据，shuffle</pre></td></tr><tr><td data-num="5"></td><td><pre>           参数<span class="token number">3</span>：partitionCoalescer: <span class="token keyword">Option</span><span class="token punctuation">[</span>PartitionCoalescer<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">Option</span><span class="token punctuation">.</span>empty</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">--3. 作用：缩减分区数量</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">--4. 说明：</span></pre></td></tr><tr><td data-num="9"></td><td><pre>           a、该算子重点在减少分区，我们在重置分区的个数的时候，参数值不要比原有分区数量多，因为<span class="token string">"该算子默认是不会</span></pre></td></tr><tr><td data-num="10"></td><td><pre>              打乱数据重新，没有shuffle"，所以分区设置多了，多余的分区不会有数据。</pre></td></tr><tr><td data-num="11"></td><td><pre>           b、我们在使用这个算子的时候，只需要传递重置的分区数量即可，其他的参数使用默认值；</pre></td></tr><tr><td data-num="12"></td><td><pre>           c、如果想扩大分区，有新的算子可以实现，不过底层还是调用<span class="token keyword">coalesce</span>，只是将参数<span class="token number">2</span>设置为<span class="token boolean">true</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">--5. 应用场景：</span></pre></td></tr><tr><td data-num="14"></td><td><pre>           a、数据经过过滤以后，发现数据不均匀，使用这个算子来减少分区的数量</pre></td></tr><tr><td data-num="15"></td><td><pre>           b、数据分区设置的不合理，也可以使用这个方法。</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>distinct<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">val</span> rdd2<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>coalesce<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    rdd2<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="55311-repartition"><a class="anchor" href="#55311-repartition">#</a> 5.5.3.11 rePartition</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：rePartition (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 底层逻辑：调用了 coalesce 算子，只是将 shuffle 的值改为了 true，执行 shuffle 过程。</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            def repartition<span class="token punctuation">(</span>numPartitions: <span class="token keyword">Int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>implicit ord: Ordering<span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">null</span><span class="token punctuation">)</span>: RDD<span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token operator">=</span> withScope &#123;</pre></td></tr><tr><td data-num="4"></td><td><pre>            <span class="token keyword">coalesce</span><span class="token punctuation">(</span>numPartitions<span class="token punctuation">,</span> shuffle <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>          &#125;</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">--3. 参数：numPartitions: Int: 重新分区的数量</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">--4. 作用：扩大分区，重分区</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">--5. 说明：</span></pre></td></tr><tr><td data-num="9"></td><td><pre>            这个参数即可以扩大分区，也可以缩小分区的数量，但是我们一般用来扩大分区。</pre></td></tr><tr><td data-num="10"></td><td><pre>            缩小分区可以使用<span class="token keyword">coalesce</span>算子</pre></td></tr><tr><td data-num="11"></td><td><pre>   <span class="token comment">--6. coalesce 和  rePartition 算子的使用选择</span></pre></td></tr><tr><td data-num="12"></td><td><pre>           a、如果是减少分区，那么就使用<span class="token keyword">coalesce</span></pre></td></tr><tr><td data-num="13"></td><td><pre>           b、如果是扩大分区，那么就使用rePartition</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>distinct<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    rdd1<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output1"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">/*</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    output1:</pre></td></tr><tr><td data-num="7"></td><td><pre>    分区 0：6 3 12</pre></td></tr><tr><td data-num="8"></td><td><pre>    分区 1：4 1</pre></td></tr><tr><td data-num="9"></td><td><pre>    分区 2：5 2</pre></td></tr><tr><td data-num="10"></td><td><pre>     */</pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token keyword">val</span> rdd2<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>coalesce<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    rdd2<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output2"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">/*</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    output2: 同一分区的数据还在一起</pre></td></tr><tr><td data-num="16"></td><td><pre>    分区 0：6 3 12 4 1</pre></td></tr><tr><td data-num="17"></td><td><pre>    分区 1：5 2</pre></td></tr><tr><td data-num="18"></td><td><pre>    */</pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">val</span> rdd3<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>repartition<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    rdd3<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output3"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token comment">/*</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    output3: 数据从原来的分区打乱重组</pre></td></tr><tr><td data-num="24"></td><td><pre>    分区 0：6 12 1 5</pre></td></tr><tr><td data-num="25"></td><td><pre>    分区 1：3 4 2</pre></td></tr><tr><td data-num="26"></td><td><pre>    */</pre></td></tr></table></figure><h5 id="55312-sortby"><a class="anchor" href="#55312-sortby">#</a> 5.5.3.12 sortBy</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：sortBy (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：参数有 3 个：</span></pre></td></tr><tr><td data-num="3"></td><td><pre>            形参<span class="token number">1</span>：f: <span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> K：</pre></td></tr><tr><td data-num="4"></td><td><pre>                  T：数据集中的每一个元素</pre></td></tr><tr><td data-num="5"></td><td><pre>                  K：排序的K</pre></td></tr><tr><td data-num="6"></td><td><pre>            形参<span class="token number">2</span>：ascending: <span class="token keyword">Boolean</span> <span class="token operator">=</span> <span class="token boolean">true</span></pre></td></tr><tr><td data-num="7"></td><td><pre>                  排序的方式，默认值为ture，为升序，</pre></td></tr><tr><td data-num="8"></td><td><pre>                  如果改为<span class="token boolean">false</span>，则是降序</pre></td></tr><tr><td data-num="9"></td><td><pre>            形参<span class="token number">3</span>： numPartitions: <span class="token keyword">Int</span> <span class="token operator">=</span> this<span class="token punctuation">.</span>partitions<span class="token punctuation">.</span>length</pre></td></tr><tr><td data-num="10"></td><td><pre>                  排序后的分区数量，默认值为前一个RDD的分区数量。</pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">--3. 作用：按照指定的规则进行排序</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// 降序排序：</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>sortBy<span class="token punctuation">(</span>num <span class="token keyword">=></span> num<span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//6,5,4,3,2,1</span></pre></td></tr></table></figure><h5 id="55313-双value数据类型"><a class="anchor" href="#55313-双value数据类型">#</a> 5.5.3.13 双 Value 数据类型</h5><blockquote><p>双 Value：表示是两个 RDD 之间进行操作，类似 sacla 中集合的并集 (union)、交集 (intersect)、差集 (diff)、拉链（zip）</p></blockquote><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：union</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 作用：并集</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">--3. 说明</span></pre></td></tr><tr><td data-num="4"></td><td><pre>       a、分区：分区合并</pre></td></tr><tr><td data-num="5"></td><td><pre>       b、数据：数据合并</pre></td></tr><tr><td data-num="6"></td><td><pre>       c、两个RDD的数据类型必须保持一致，否者编译不通过</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> rdd1 <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd2<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">val</span> result1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>union<span class="token punctuation">(</span>rdd2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    println<span class="token punctuation">(</span>result1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    result1<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output1"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：intersection</span></pre></td></tr><tr><td data-num="2"></td><td><pre>     <span class="token comment">--2. 作用：交集</span></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token comment">--3. 说明</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        a、数据打乱重组，有shuffle过程；</pre></td></tr><tr><td data-num="5"></td><td><pre>        b、两个RDD的数据类型必须保持一致，否者编译时报错</pre></td></tr><tr><td data-num="6"></td><td><pre>        c、返回的RDD的分区数量保留两个RDD最大的分区数量</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> result2 <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>intersection<span class="token punctuation">(</span>rdd2<span class="token punctuation">)</span></pre></td></tr></table></figure><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：subtract</span></pre></td></tr><tr><td data-num="2"></td><td><pre>     <span class="token comment">--2. 作用：差集</span></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token comment">--3. 说明</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        a、分区：返回的RDD的分区数量等于调用这个方法的RDD的分区数量</pre></td></tr><tr><td data-num="5"></td><td><pre>        b、有数据打乱重组过程，有shuffle过程</pre></td></tr><tr><td data-num="6"></td><td><pre>        c、数据：返回当前RDD除去和参数RDD共同的数据集</pre></td></tr><tr><td data-num="7"></td><td><pre>        d、两个RDD的数据类型必须保持一致，否者编译时报错</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> result3<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>subtract<span class="token punctuation">(</span>rdd2<span class="token punctuation">)</span></pre></td></tr></table></figure><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：zip</span></pre></td></tr><tr><td data-num="2"></td><td><pre>     <span class="token comment">--2. 作用：拉链</span></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token comment">--3. 说明：</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        a、分区数量相同，每个分区的数据量不相等，</pre></td></tr><tr><td data-num="5"></td><td><pre>        报错：Can only zip RDDs <span class="token keyword">with</span> same number <span class="token keyword">of</span> elements <span class="token operator">in</span> each <span class="token keyword">partition</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        只有两个RDD的每个分区数据量相同才能拉链</pre></td></tr><tr><td data-num="7"></td><td><pre>        b、分区数量不相同，每个分区的数量量相同，</pre></td></tr><tr><td data-num="8"></td><td><pre>        报错：Can't zip RDDs <span class="token keyword">with</span> unequal numbers <span class="token keyword">of</span> partitions</pre></td></tr><tr><td data-num="9"></td><td><pre>        RDD的分区数量不同不能拉链</pre></td></tr><tr><td data-num="10"></td><td><pre>        综上：只要两个RDD的分区数量和每个分区数据量相等，才不会报错。</pre></td></tr><tr><td data-num="11"></td><td><pre>        c、返回的RDD的数据是元组</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> result4<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>zip<span class="token punctuation">(</span>rdd2<span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="55314-key-value类型"><a class="anchor" href="#55314-key-value类型">#</a> 5.5.3.14 key-value 类型</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1.Spark 中有很多方法都是基于 Key 进行操作，所以数据格式应该为键值对 (对偶元素) 才能使用这些方法</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 如果数据类型是 kv 类型，那么 Spark 会将 RDD 自动转换补充很多新的功能 --> 功能的扩展</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">--3. 那么是如果实现的？</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      a、通过隐式转换</pre></td></tr><tr><td data-num="5"></td><td><pre>      b、如果数据类型为kv类型，在RDD的伴生对象中会将当前的RDD会转换为PairRDDFunctions对象</pre></td></tr><tr><td data-num="6"></td><td><pre>      c、如下的partitionBy就是来自PairRDDFunctions类中的方法</pre></td></tr></table></figure><h5 id="55315-partitionby"><a class="anchor" href="#55315-partitionby">#</a> 5.5.3.15 partitionBy</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：partitionBy (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：partitioner: Partitioner：是一个分区器对象。</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">--3. 作用：根据指定的规则对数据进行分区，指定数据进入到哪一个分区。</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">--4. 当前能改变分区的算子有：</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      groupBy、<span class="token keyword">coalesce</span>、rePartition <span class="token comment">--> 改变分区的数据，但是并不能指定数据去到指定的分区</span></pre></td></tr><tr><td data-num="7"></td><td><pre>      而partitionBy就是来处理将数据指定去到哪个分区。</pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">--5. 什么是分区器？</span></pre></td></tr><tr><td data-num="10"></td><td><pre>       a、Partitioner是一个抽象类，有两个抽象方法：</pre></td></tr><tr><td data-num="11"></td><td><pre>          方法<span class="token number">1</span>：def numPartitions: <span class="token keyword">Int</span>  <span class="token comment">-- 用来获取当前的分区数量</span></pre></td></tr><tr><td data-num="12"></td><td><pre>          方法<span class="token number">2</span>：def getPartition<span class="token punctuation">(</span><span class="token keyword">key</span>: <span class="token keyword">Any</span><span class="token punctuation">)</span>: <span class="token keyword">Int</span>  <span class="token comment">-- 根据数据的 key，返回数据所在的分区号      </span></pre></td></tr><tr><td data-num="13"></td><td><pre>       b、Partitioner有三个实现类：</pre></td></tr><tr><td data-num="14"></td><td><pre>          <span class="token number">1.</span>HashPartitioner</pre></td></tr><tr><td data-num="15"></td><td><pre>          <span class="token number">2.</span>RangePartitioner</pre></td></tr><tr><td data-num="16"></td><td><pre>          <span class="token number">3.</span>PythonPartitioner</pre></td></tr><tr><td data-num="17"></td><td><pre>       c、HashPartitioner:</pre></td></tr><tr><td data-num="18"></td><td><pre>          <span class="token number">1.</span>是Spark默认的分区器</pre></td></tr><tr><td data-num="19"></td><td><pre>          <span class="token number">2.</span>分区规则：将当前数据的<span class="token keyword">Key</span>的哈希值 <span class="token operator">%</span> 分区数量</pre></td></tr><tr><td data-num="20"></td><td><pre>          <span class="token number">3.</span>形参需要传递分区的数量。</pre></td></tr><tr><td data-num="21"></td><td><pre>       d、RangePartitioner：范围分区器，指定每个分区的<span class="token keyword">key</span>范围，在这个范围的<span class="token keyword">key</span>就进入这个分区</pre></td></tr><tr><td data-num="22"></td><td><pre>          这需要<span class="token keyword">key</span>能比较大小。</pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>     <span class="token comment">--6. 注意事项：如果重分区的分区器和当前 RDD 的分区器相同，那么数据不会重新分区。</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>     <span class="token comment">--7. 自定义分区器：</span></pre></td></tr><tr><td data-num="27"></td><td><pre>       步骤：</pre></td></tr><tr><td data-num="28"></td><td><pre>       a、创建一个类，有一个分区数量的属性，然后extends Partitioner</pre></td></tr><tr><td data-num="29"></td><td><pre>       b、重写Partitioner中的两个抽象方法</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> sparkConf<span class="token operator">:</span> SparkConf <span class="token operator">=</span> <span class="token keyword">new</span> SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setMaster<span class="token punctuation">(</span><span class="token string">"local[*]"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setAppName<span class="token punctuation">(</span><span class="token string">"RDD"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> SparkContext<span class="token punctuation">(</span>sparkConf<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">//    rdd.saveAsTextFile("output1")</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>partitionBy<span class="token punctuation">(</span><span class="token keyword">new</span> HashPartitioner<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">//    rdd1.saveAsTextFile("output2")</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">val</span> list1 <span class="token operator">=</span> List<span class="token punctuation">(</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token punctuation">(</span><span class="token string">"cba"</span><span class="token punctuation">,</span> <span class="token string">"消息1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token punctuation">(</span><span class="token string">"nba"</span><span class="token punctuation">,</span> <span class="token string">"消息5"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre>      <span class="token punctuation">(</span><span class="token string">"wnba"</span><span class="token punctuation">,</span> <span class="token string">"消息10"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token punctuation">(</span><span class="token string">"cba"</span><span class="token punctuation">,</span> <span class="token string">"消息2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      <span class="token punctuation">(</span><span class="token string">"nba"</span><span class="token punctuation">,</span> <span class="token string">"消息2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="16"></td><td><pre>      <span class="token punctuation">(</span><span class="token string">"wnba"</span><span class="token punctuation">,</span> <span class="token string">"消息6"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="17"></td><td><pre>      <span class="token punctuation">(</span><span class="token string">"cba"</span><span class="token punctuation">,</span> <span class="token string">"消息1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">val</span> rddInfo<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list1<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">val</span> partitionRDD<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rddInfo<span class="token punctuation">.</span>partitionBy<span class="token punctuation">(</span><span class="token keyword">new</span> MyPartitioner<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    partitionRDD<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>    sc<span class="token punctuation">.</span>stop<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="25"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment">// 自定义分区器</span></pre></td></tr><tr><td data-num="27"></td><td><pre>  <span class="token keyword">class</span> MyPartitioner<span class="token punctuation">(</span>num<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token keyword">extends</span>  Partitioner <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    <span class="token keyword">override</span> <span class="token keyword">def</span> numPartitions<span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> num</pre></td></tr><tr><td data-num="29"></td><td><pre></pre></td></tr><tr><td data-num="30"></td><td><pre>    <span class="token keyword">override</span> <span class="token keyword">def</span> getPartition<span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token builtin">Any</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>      key <span class="token keyword">match</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token keyword">case</span> <span class="token string">"nba"</span> <span class="token keyword">=></span> <span class="token number">0</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token keyword">case</span> _ <span class="token keyword">=></span> <span class="token number">1</span></pre></td></tr><tr><td data-num="34"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="55316-reducebykey"><a class="anchor" href="#55316-reducebykey">#</a> 5.5.3.16 reduceByKey</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：reduceByKey (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>     <span class="token comment">--2. 形参：有三个重载的方法，我们这里介绍两种。</span></pre></td></tr><tr><td data-num="3"></td><td><pre>        方法<span class="token number">1</span>：</pre></td></tr><tr><td data-num="4"></td><td><pre>        形参：func: <span class="token punctuation">(</span>V<span class="token punctuation">,</span> V<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> V ，是一个函数</pre></td></tr><tr><td data-num="5"></td><td><pre>             函数的形参为：表示相同<span class="token keyword">Key</span>的<span class="token keyword">value</span></pre></td></tr><tr><td data-num="6"></td><td><pre>             函数返回值：经过聚合以后的结果，返回值数据类型和原数据<span class="token keyword">value</span>类型一致</pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>        方法<span class="token number">2</span>：</pre></td></tr><tr><td data-num="9"></td><td><pre>        形参：func: <span class="token punctuation">(</span>V<span class="token punctuation">,</span> V<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> V<span class="token punctuation">,</span> numPartitions: <span class="token keyword">Int</span></pre></td></tr><tr><td data-num="10"></td><td><pre>        形参<span class="token number">1</span>：与方法<span class="token number">1</span>一致</pre></td></tr><tr><td data-num="11"></td><td><pre>        形参<span class="token number">2</span>：定义聚合以后分区的数量</pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>     <span class="token comment">--3. 作用：根据数据的 Key 进行分组，对相同 Key 的 value 进行数据处理</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    rdd<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>reduceByKey<span class="token punctuation">(</span>_  <span class="token operator">+</span> _<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    rdd1<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output1"</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>![image-20200606000759888](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200606000759.png)</p><h5 id="55317-groupbykey"><a class="anchor" href="#55317-groupbykey">#</a> 5.5.3.17 groupByKey</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：groupByKey (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>     <span class="token comment">--2. 形参：有三个重载的方法：分别是 (无参)、(partitioner: Partitioner)、(numPartitions: Int)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token comment">--3. 返回值：RDD [(K, Iterable [V])]，是一个元组</span></pre></td></tr><tr><td data-num="4"></td><td><pre>               第一元素：表示用于分组的<span class="token keyword">key</span></pre></td></tr><tr><td data-num="5"></td><td><pre>               第二元素：表示分组后相同<span class="token keyword">key</span>的<span class="token keyword">value</span>的集合</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>     <span class="token comment">--4. 作用：根据数据的 key 进行分组</span></pre></td></tr><tr><td data-num="8"></td><td><pre>     <span class="token comment">--5. 对比 groupBy: 按照指定的规则进行分组</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>     <span class="token comment">--6. 补充知识点：</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token number">1.</span> shuffle过程必须落盘。</pre></td></tr><tr><td data-num="12"></td><td><pre>            <span class="token number">2.</span> 一个分区就是一个task，如果处理过程有shuffle过程，那么将会把task一分为二</pre></td></tr><tr><td data-num="13"></td><td><pre>               有shuffle过程，会生产新的分区，生产新的task。</pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token number">3.</span> 判断一个算子的效率，取决于shuffle的效率，落盘的数据越少，读取的数据越少，则效率越高</pre></td></tr><tr><td data-num="15"></td><td><pre>     <span class="token comment">--7. 关于 reduceByKey 和 groupByKey 的区别。</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            <span class="token number">1.</span> 算子的作用：</pre></td></tr><tr><td data-num="17"></td><td><pre>                reduceByKey：根据<span class="token keyword">key</span>进行分组，对相同的<span class="token keyword">key</span>的<span class="token keyword">value</span>进行操作</pre></td></tr><tr><td data-num="18"></td><td><pre>                groupByKey：对<span class="token keyword">key</span>进行分组</pre></td></tr><tr><td data-num="19"></td><td><pre>            <span class="token number">2.</span> groupByKey</pre></td></tr><tr><td data-num="20"></td><td><pre>                a、对一个分区的数据分区后不能继续执行后续的操作，需要等到其他分区的数据全部到达后，才能执行后续的操作</pre></td></tr><tr><td data-num="21"></td><td><pre>                b、groupByKey是面向整个数据集，而不是面向一个分区</pre></td></tr><tr><td data-num="22"></td><td><pre>                c、但是如果在内存等待，那么可能由于内存不够，导致执行失败，所以这个等待的过程依靠落盘<span class="token punctuation">.</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token number">3.</span>reduceByKey:</pre></td></tr><tr><td data-num="25"></td><td><pre>                a、在shuffle之前进行分区内的聚合操作，称之为预聚合，这样shuffle时，落盘的数据就会减少，提高了shuff的</pre></td></tr><tr><td data-num="26"></td><td><pre>                   效率</pre></td></tr><tr><td data-num="27"></td><td><pre>                b、分区内和分区间的规则相同。</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> Iterable<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>groupByKey<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    rdd1<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">//(b,CompactBuffer(1, 5)),(a,CompactBuffer(2, 3))</span></pre></td></tr></table></figure><p>![image-20200606000826608](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200606000826.png)</p><h5 id="55318-aggregatebykey"><a class="anchor" href="#55318-aggregatebykey">#</a> 5.5.3.18 aggregateByKey</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：aggregateByKey (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：两个形参列表</span></pre></td></tr><tr><td data-num="3"></td><td><pre>           a、形参列表<span class="token number">1</span>：<span class="token punctuation">(</span>zeroValue: U<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>              参数：表示计算的初始值</pre></td></tr><tr><td data-num="5"></td><td><pre>           b、形参列表<span class="token number">2</span>：<span class="token punctuation">(</span>seqOp: <span class="token punctuation">(</span>U<span class="token punctuation">,</span> V<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> U<span class="token punctuation">,</span>combOp: <span class="token punctuation">(</span>U<span class="token punctuation">,</span> U<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> U<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>              参数<span class="token number">1</span>：seqOp: <span class="token punctuation">(</span>U<span class="token punctuation">,</span> V<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> U：是一个函数，表示分区内相同<span class="token keyword">key</span>的<span class="token keyword">value</span>的计算规则</pre></td></tr><tr><td data-num="7"></td><td><pre>                    函数的形参：第一个参数按照计算规则和第一个<span class="token keyword">value</span>计算的结果，类型和初始值类型相同，第二个参数为数据的V</pre></td></tr><tr><td data-num="8"></td><td><pre>                    函数的返回值：返回和第一个参数一样的数据类型</pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>              参数<span class="token number">2</span>：combOp: <span class="token punctuation">(</span>U<span class="token punctuation">,</span> U<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> U：是一个函数，表示分区间，相同<span class="token keyword">key</span>的<span class="token keyword">value</span>的计算规则</pre></td></tr><tr><td data-num="11"></td><td><pre>                    函数的形参：两个参数为每个分区的计算结果，类型和初始值类型相同</pre></td></tr><tr><td data-num="12"></td><td><pre>                    函数的返回值：返回和第一个参数一样的数据类型</pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">--3. 作用：根据 key 进行聚合，分区内和分区间的执行逻辑均是针对于 value 的操作</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">--4. 使用场景：</span></pre></td></tr><tr><td data-num="15"></td><td><pre>         a、当出现分区内和分区间对数据处理的规则不一样时，使用这个算子。</pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token comment">--5. 当分区内计算规则和分区间的计算规则相同时，可以使用 foldByKey 进行替代。</span></pre></td></tr><tr><td data-num="17"></td><td><pre>         def foldByKey<span class="token punctuation">(</span>zeroValue: V<span class="token punctuation">)</span><span class="token punctuation">(</span>func: <span class="token punctuation">(</span>V<span class="token punctuation">,</span> V<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> V<span class="token punctuation">)</span>: RDD<span class="token punctuation">[</span><span class="token punctuation">(</span>K<span class="token punctuation">,</span> V<span class="token punctuation">)</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">--6. 说明：</span></pre></td></tr><tr><td data-num="19"></td><td><pre>         a、初始值只参与分区内相同<span class="token keyword">key</span>的第一次运算，而且初始值为<span class="token keyword">value</span>值</pre></td></tr><tr><td data-num="20"></td><td><pre>         b、可以初始值的方式改变数据结构</pre></td></tr></table></figure><p>![image-20200606000641855](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200606000641.png)</p><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    需求：求分区内相同 key 的 value 最大值，然后再求分区间相同 key 的 value 总和</pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    分区内：</pre></td></tr><tr><td data-num="5"></td><td><pre>    分区 0：</pre></td></tr><tr><td data-num="6"></td><td><pre>    ("a",2), ("a",3), ("b",4),</pre></td></tr><tr><td data-num="7"></td><td><pre>    =>("a",3),("b",4)</pre></td></tr><tr><td data-num="8"></td><td><pre>    分区 1：</pre></td></tr><tr><td data-num="9"></td><td><pre>    ("b",2), ("a",5), ("b",3)</pre></td></tr><tr><td data-num="10"></td><td><pre>    =>("b",3),("a",5)</pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>    分区间：</pre></td></tr><tr><td data-num="13"></td><td><pre>    ("a",8)</pre></td></tr><tr><td data-num="14"></td><td><pre>    ("b",7)</pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>     */</pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span></pre></td></tr><tr><td data-num="18"></td><td><pre>      <span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="19"></td><td><pre>      <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>aggregateByKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="23"></td><td><pre>      <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        x <span class="token operator">+</span> y</pre></td></tr><tr><td data-num="25"></td><td><pre>      <span class="token punctuation">&#125;</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="26"></td><td><pre></pre></td></tr><tr><td data-num="27"></td><td><pre>      <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        x <span class="token operator">+</span> y</pre></td></tr><tr><td data-num="29"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="30"></td><td><pre></pre></td></tr><tr><td data-num="31"></td><td><pre></pre></td></tr><tr><td data-num="32"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="34"></td><td><pre></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token keyword">val</span> rdd2<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>foldByKey<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_ <span class="token operator">+</span> _ <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    println<span class="token punctuation">(</span>rdd2<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="55319-combinebykey"><a class="anchor" href="#55319-combinebykey">#</a> 5.5.3.19 combineByKey</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：combineByKey (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参： 相同 key 内进行操作</span></pre></td></tr><tr><td data-num="3"></td><td><pre>       参数<span class="token number">1</span>：createCombiner: V <span class="token operator">=</span><span class="token operator">></span> C<span class="token punctuation">,</span>表示将计算的第一个值进行结构转化</pre></td></tr><tr><td data-num="4"></td><td><pre>             形参：相同<span class="token keyword">key</span>组内的第一个<span class="token keyword">value</span>元素</pre></td></tr><tr><td data-num="5"></td><td><pre>             返回：<span class="token keyword">value</span>经过转换后的数据</pre></td></tr><tr><td data-num="6"></td><td><pre>       参数<span class="token number">2</span>：mergeValue: <span class="token punctuation">(</span>C<span class="token punctuation">,</span> V<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> C<span class="token punctuation">,</span>表示分区内的计算规则</pre></td></tr><tr><td data-num="7"></td><td><pre>             形参：参数<span class="token number">1</span>为经过处理后<span class="token keyword">value</span>，参数<span class="token number">2</span>为组内的一个一个的<span class="token keyword">value</span></pre></td></tr><tr><td data-num="8"></td><td><pre>             返回：<span class="token keyword">value</span>经过处理后的数据</pre></td></tr><tr><td data-num="9"></td><td><pre>       参数<span class="token number">3</span>：mergeCombiners: <span class="token punctuation">(</span>C<span class="token punctuation">,</span> C<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> C<span class="token punctuation">)</span>：表示分区间的计算规则</pre></td></tr><tr><td data-num="10"></td><td><pre>             形参：相同<span class="token keyword">key</span>，两个经过分区内处理过的v</pre></td></tr><tr><td data-num="11"></td><td><pre>             返回：返回两个v的处理结果</pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">--3. 作用：均是对 key 为组进行合并，对 value 进行数据处理</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token comment">--4. 使用场景：当计算时发现 key 的 value 不符合计算规则的格式时，那么选择 conbineByKey</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/*</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    需求：将数据</pre></td></tr><tr><td data-num="3"></td><td><pre>    List (("a", 88), ("b", 95), ("a", 91), ("b", 93), ("a", 95), ("b", 98))</pre></td></tr><tr><td data-num="4"></td><td><pre>    求每个 key 的平均值</pre></td></tr><tr><td data-num="5"></td><td><pre>     */</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">val</span> list <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">95</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">91</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">93</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">95</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>combineByKey<span class="token punctuation">(</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>      v <span class="token keyword">=></span> <span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token punctuation">(</span>tuple<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">(</span>tuple<span class="token punctuation">.</span>_1 <span class="token operator">+</span> v<span class="token punctuation">,</span> tuple<span class="token punctuation">.</span>_2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre>      <span class="token punctuation">(</span>tuple<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tuple2<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        <span class="token punctuation">(</span>tuple<span class="token punctuation">.</span>_1 <span class="token operator">+</span> tuple2<span class="token punctuation">.</span>_1<span class="token punctuation">,</span> tuple<span class="token punctuation">.</span>_2 <span class="token operator">+</span> tuple2<span class="token punctuation">.</span>_2<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token keyword">val</span> mapRDD<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> rdd1<span class="token punctuation">.</span>map <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>      <span class="token keyword">case</span> <span class="token punctuation">(</span>word<span class="token punctuation">,</span> <span class="token punctuation">(</span>sum<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">(</span>word<span class="token punctuation">,</span> sum <span class="token operator">/</span> count<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="19"></td><td><pre></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>    println<span class="token punctuation">(</span>mapRDD<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><p>![image-20200606000722774](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200606000722.png)</p><h5 id="55320-几个bykey的区别"><a class="anchor" href="#55320-几个bykey的区别">#</a> 5.5.3.20 几个 ByKey 的区别</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- reduceByKey、foldByKey、aggregateByKey、combineByKey 的区别</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>     <span class="token number">1.</span>从源码的角度发现，如上<span class="token number">4</span>个算子底层逻辑是相同，唯一不同的区别是参数不同。</pre></td></tr><tr><td data-num="4"></td><td><pre>          参数<span class="token number">1</span>： createCombiner，分区内每个<span class="token keyword">key</span>的第一个v的转换逻辑</pre></td></tr><tr><td data-num="5"></td><td><pre>          参数<span class="token number">2</span>： mergeValue，分区内部的计算逻辑</pre></td></tr><tr><td data-num="6"></td><td><pre>          参数<span class="token number">3</span>： mergeCombiners，分区间的计算逻辑</pre></td></tr><tr><td data-num="7"></td><td><pre>              def combineByKeyWithClassTag<span class="token punctuation">[</span>C<span class="token punctuation">]</span><span class="token punctuation">(</span></pre></td></tr><tr><td data-num="8"></td><td><pre>                  createCombiner: V <span class="token operator">=</span><span class="token operator">></span> C<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="9"></td><td><pre>                  mergeValue: <span class="token punctuation">(</span>C<span class="token punctuation">,</span> V<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> C<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="10"></td><td><pre>                  mergeCombiners: <span class="token punctuation">(</span>C<span class="token punctuation">,</span> C<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> C<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                  partitioner: Partitioner<span class="token punctuation">,</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                  mapSideCombine: <span class="token keyword">Boolean</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                  serializer: Serializer <span class="token operator">=</span> <span class="token boolean">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre>      </pre></td></tr><tr><td data-num="15"></td><td><pre>        <span class="token comment">--2.reduceByKey：</span></pre></td></tr><tr><td data-num="16"></td><td><pre>            源码如下：</pre></td></tr><tr><td data-num="17"></td><td><pre>            <span class="token comment">-- 参数 1：没有任何的转换，对 key 的第一个 value 没有转换</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token comment">-- 参数 2 和参数 3 相同，即分区内和分区间的计算逻辑保持一致。</span></pre></td></tr><tr><td data-num="19"></td><td><pre>            combineByKeyWithClassTag<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v: V<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> v<span class="token punctuation">,</span> func<span class="token punctuation">,</span> func<span class="token punctuation">,</span> partitioner<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="20"></td><td><pre></pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token comment">--3.aggregateByKey</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            源码如下：</pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token comment">-- 参数 1：传递的初始值会和每一个 key 的第一个 value 按照分区内计算逻辑进行计算</span></pre></td></tr><tr><td data-num="24"></td><td><pre>            <span class="token comment">-- 参数 2：分区内计算逻辑</span></pre></td></tr><tr><td data-num="25"></td><td><pre>            <span class="token comment">-- 参数 3：分区间的计算逻辑</span></pre></td></tr><tr><td data-num="26"></td><td><pre>           combineByKeyWithClassTag<span class="token punctuation">[</span>U<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v: V<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> cleanedSeqOp<span class="token punctuation">(</span>createZero<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">,</span>cleanedSeqOp<span class="token punctuation">,</span> combOp<span class="token punctuation">,</span> partitioner<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="27"></td><td><pre>       </pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token comment">--4.foldByKey</span></pre></td></tr><tr><td data-num="29"></td><td><pre>            源码如下：</pre></td></tr><tr><td data-num="30"></td><td><pre>            <span class="token comment">-- 参数 1：传递的初始值会和每一个 key 的第一个 value 按照分区内计算逻辑进行计算</span></pre></td></tr><tr><td data-num="31"></td><td><pre>            <span class="token comment">-- 参数 2 和参数 3 一致：分区内和分区间的计算逻辑保持一致</span></pre></td></tr><tr><td data-num="32"></td><td><pre>          combineByKeyWithClassTag<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v: V<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> cleanedFunc<span class="token punctuation">(</span>createZero<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">,</span> cleanedFunc<span class="token punctuation">,</span> cleanedFunc<span class="token punctuation">,</span> partitioner<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token comment">--5.combineByKey</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            源码如下：</pre></td></tr><tr><td data-num="35"></td><td><pre>            <span class="token comment">-- 参数 1：分区内每个 key 的第一个 v 的转换逻辑，所以去无需传递初始值</span></pre></td></tr><tr><td data-num="36"></td><td><pre>            <span class="token comment">-- 参数 2：分区内计算逻辑</span></pre></td></tr><tr><td data-num="37"></td><td><pre>            <span class="token comment">-- 参数 3：分区间的计算逻辑</span></pre></td></tr><tr><td data-num="38"></td><td><pre>        combineByKeyWithClassTag<span class="token punctuation">(</span>createCombiner<span class="token punctuation">,</span> mergeValue<span class="token punctuation">,</span> mergeCombiners<span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="55321-sortbykey"><a class="anchor" href="#55321-sortbykey">#</a> 5.5.3.21 sortByKey</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：sortByKey (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：有两个形参，均有默认值：</span></pre></td></tr><tr><td data-num="3"></td><td><pre>           形参<span class="token number">1</span>：ascending: <span class="token keyword">Boolean</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>                 排序的顺序，默认是升序，如果需要降序，则输入<span class="token boolean">false</span></pre></td></tr><tr><td data-num="5"></td><td><pre>           形参<span class="token number">2</span>：numPartitions: <span class="token keyword">Int</span> <span class="token operator">=</span> self<span class="token punctuation">.</span>partitions<span class="token punctuation">.</span>length：</pre></td></tr><tr><td data-num="6"></td><td><pre>                 排序以后分区的数量，默认等于上一个rdd的分区的数量。</pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">--3. 作用：根据 key 进行排序，默认是升序</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">--4. 说明:</span></pre></td></tr><tr><td data-num="9"></td><td><pre>           还可以自定义分区的规则。步骤：</pre></td></tr><tr><td data-num="10"></td><td><pre>           <span class="token number">1.</span>继承与ordered，并混入<span class="token keyword">serializable</span></pre></td></tr><tr><td data-num="11"></td><td><pre>           <span class="token number">2.</span>重写compare方法，指定排序比较的规则</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    println<span class="token punctuation">(</span>rdd<span class="token punctuation">.</span>sortByKey<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>  </pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">val</span> user1 <span class="token operator">=</span> User<span class="token punctuation">(</span><span class="token string">"scala"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">val</span> user2<span class="token operator">:</span> User <span class="token operator">=</span> User<span class="token punctuation">(</span><span class="token string">"scala"</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">val</span> user3<span class="token operator">:</span> User <span class="token operator">=</span> User<span class="token punctuation">(</span><span class="token string">"hadoop"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    </pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">val</span> rdd2<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span>User<span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token punctuation">(</span>user1<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>user2<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>user3<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    println<span class="token punctuation">(</span>rdd2<span class="token punctuation">.</span>sortByKey<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>  </pre></td></tr><tr><td data-num="14"></td><td><pre>  <span class="token comment">// 自定义排序方式</span></pre></td></tr><tr><td data-num="15"></td><td><pre>  <span class="token keyword">case</span> <span class="token keyword">class</span> User<span class="token punctuation">(</span>name<span class="token operator">:</span><span class="token builtin">String</span><span class="token punctuation">,</span>age<span class="token operator">:</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token keyword">extends</span>  Ordered<span class="token punctuation">[</span>User<span class="token punctuation">]</span> <span class="token keyword">with</span>  Serializable<span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>     <span class="token keyword">override</span> <span class="token keyword">def</span> compare<span class="token punctuation">(</span>that<span class="token operator">:</span> User<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">></span> that<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>          <span class="token number">1</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">==</span> that<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>          <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">-</span> that<span class="token punctuation">.</span>age</pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>          <span class="token operator">-</span><span class="token number">1</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre>     <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>   <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h5 id="55322-join"><a class="anchor" href="#55322-join">#</a> 5.5.3.22 join</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：Join (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：(other: RDD [(K, W)]): 另外一个 RDD</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">--3. 算子的返回值：RDD [(K, (V, W))]</span></pre></td></tr><tr><td data-num="4"></td><td><pre>          返回一个元组：</pre></td></tr><tr><td data-num="5"></td><td><pre>          元组的第一个元素：两个rdd连接的<span class="token keyword">Key</span></pre></td></tr><tr><td data-num="6"></td><td><pre>          元组的第二个元素：相同<span class="token keyword">key</span>的<span class="token keyword">value</span>，一个来自当前RDD，一个来自另外一个RDD</pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">--4. 作用：将两个 RDD 中，key 相同的 value 一一进行连接，类似 mysql 中的 join，会出现笛卡尔积错误</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">--5. 说明:</span></pre></td></tr><tr><td data-num="10"></td><td><pre>       情况<span class="token number">1</span>：如果当前RDD中<span class="token keyword">key</span>在连接的RDD中没有，那么这条数据就不会被关联，数据则没有</pre></td></tr><tr><td data-num="11"></td><td><pre>       情况<span class="token number">2</span>：如果当前RDD中相同的<span class="token keyword">Key</span>有多条数据，且另外一个RDD与子相同的<span class="token keyword">key</span>也有多条数据，那么就出现了笛卡尔积错误</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    println<span class="token punctuation">(</span>rdd<span class="token punctuation">.</span>join<span class="token punctuation">(</span>rdd1<span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//(a,(1,21)),(b,(1,2))</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">val</span> rdd2<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">val</span> rdd3<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    println<span class="token punctuation">(</span>rdd2<span class="token punctuation">.</span>join<span class="token punctuation">(</span>rdd3<span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">//(a,(1,21)),(a,(1,2)),(a,(2,21)),(a,(2,2)),(b,(1,2))</span></pre></td></tr></table></figure><h5 id="55323-leftrightouterjoin"><a class="anchor" href="#55323-leftrightouterjoin">#</a> 5.5.3.23 Left/rightOuterJoin</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：LeftOuterJoin/RightOuterJoin</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：另外一个 RDD</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">--3. 类似 mysql 中的左外连接和右外连接，同样会出现笛卡尔积错误</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">--4. 注意返回值：</span></pre></td></tr><tr><td data-num="5"></td><td><pre>       如果两个RDD有相同的<span class="token keyword">key</span>，则为：<span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token keyword">Some</span><span class="token punctuation">(</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>       如果主RDD中的<span class="token keyword">key</span>，在从RDD没有对应的<span class="token keyword">key</span>，则为：<span class="token punctuation">(</span>d<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>None<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    println<span class="token punctuation">(</span>rdd<span class="token punctuation">.</span>leftOuterJoin<span class="token punctuation">(</span>rdd1<span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">//(a,(1,Some(21))),(a,(1,Some(2))),(a,(2,Some(21))),(a,(2,Some(2))),(b,(1,Some(2))),(d,(2,None))</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    println<span class="token punctuation">(</span>rdd<span class="token punctuation">.</span>rightOuterJoin<span class="token punctuation">(</span>rdd1<span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="55324-cogroup"><a class="anchor" href="#55324-cogroup">#</a> 5.5.3.24 cogroup</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：cogroup (形参)  -->co 是 connect 的简写</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：other: RDD [(K, W)]: 另外一个 RDD</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">--3. 返回值：(K,(Iterable&lt;V>,Iterable&lt;W>))，是一个元组</span></pre></td></tr><tr><td data-num="4"></td><td><pre>              元组的第一个元素：RDD的<span class="token keyword">key</span></pre></td></tr><tr><td data-num="5"></td><td><pre>              元组的第二个元素：还是一个元组</pre></td></tr><tr><td data-num="6"></td><td><pre>                  元组的第一个元素：当前相同<span class="token keyword">key</span>的所有<span class="token keyword">value</span>的集合，是一个迭代器</pre></td></tr><tr><td data-num="7"></td><td><pre>                  元组的第二个元素：另外一个RDD的<span class="token keyword">key</span>的所有<span class="token keyword">value</span>的集合，是一个迭代器</pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">--4. 作用：将两个 RDD 中，key 相同的 value 组合在一起。</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"c"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"d"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    rdd<span class="token punctuation">.</span>cogroup<span class="token punctuation">(</span>rdd1<span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">//(a,(CompactBuffer(1),CompactBuffer(21)))</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">//(b,(CompactBuffer(1),CompactBuffer(2, 2)))</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">//(c,(CompactBuffer(1),CompactBuffer()))</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">//(d,(CompactBuffer(),CompactBuffer(1)))</span></pre></td></tr></table></figure><h5 id="55325-行动算子"><a class="anchor" href="#55325-行动算子">#</a> 5.5.3.25 行动算子</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 什么是行动算子：</span></pre></td></tr><tr><td data-num="2"></td><td><pre>       a、所谓行动算子，就是不会产生一个新的RDD，而是触发作业的执行</pre></td></tr><tr><td data-num="3"></td><td><pre>       b、而之前的转换算子，只是功能的扩展和包装，不会触发作业的执行</pre></td></tr><tr><td data-num="4"></td><td><pre>       c、行动算子执行以后，会获取当前作业的执行结果</pre></td></tr><tr><td data-num="5"></td><td><pre>       d、Spark的行动算子执行时，会产生job对象，然后提交job对象</pre></td></tr></table></figure><h5 id="55326-reduce"><a class="anchor" href="#55326-reduce">#</a> 5.5.3.26 reduce</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：reduce</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 作用：与 scala 中的 reduce 使用方式相同</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> sum<span class="token operator">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> rdd<span class="token punctuation">.</span>reduce<span class="token punctuation">(</span>_ <span class="token operator">+</span> _<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    println<span class="token punctuation">(</span>sum<span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="55327-collect"><a class="anchor" href="#55327-collect">#</a> 5.5.3.27 collect</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：collect</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 作用：采集数据，纯粹的将所有分区的计算结果拉取到当前的节点，可能会出现内存溢出的情况</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre>rdd<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="55328-count"><a class="anchor" href="#55328-count">#</a> 5.5.3.28 count</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：count</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 作用：返回当前 RDD 中数据的个数</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre>println<span class="token punctuation">(</span>rdd<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="55329-first"><a class="anchor" href="#55329-first">#</a> 5.5.3.29 first</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：first</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 作用：获取 RDD 数据集中的第一个数据</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre>println<span class="token punctuation">(</span>rdd<span class="token punctuation">.</span>first<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="55330-take"><a class="anchor" href="#55330-take">#</a> 5.5.3.30 take</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：take</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 返回当前 RDD 的前几个数据，是一个 Array 集合</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre>rdd<span class="token punctuation">.</span>take<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="55331-takeordered"><a class="anchor" href="#55331-takeordered">#</a> 5.5.3.31 takeOrdered</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：takeOrdered</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 先对 RDD 中的数据进行排序，默认升序，然后取前几个数据</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre>rdd<span class="token punctuation">.</span>takeOrdered<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="55332-sum"><a class="anchor" href="#55332-sum">#</a> 5.5.3.32 sum</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：sum</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 作用：对 RDD 集合数据求和，但是返回值类型为 Double 类型</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre>println<span class="token punctuation">(</span>rdd<span class="token punctuation">.</span>sum<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="55333-aggregate"><a class="anchor" href="#55333-aggregate">#</a> 5.5.3.33 aggregate</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：aggregate ，与 aggregateByKey 的用法类似</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：有两个形参列表：</span></pre></td></tr><tr><td data-num="3"></td><td><pre>       形参列表<span class="token number">1</span>： <span class="token punctuation">(</span>zeroValue: U<span class="token punctuation">)</span> 初始值</pre></td></tr><tr><td data-num="4"></td><td><pre>       形参列表<span class="token number">2</span>：<span class="token punctuation">(</span>seqOp: <span class="token punctuation">(</span>U<span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> U<span class="token punctuation">,</span> combOp: <span class="token punctuation">(</span>U<span class="token punctuation">,</span> U<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> U<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>          参数<span class="token number">1</span>：分区内的计算逻辑</pre></td></tr><tr><td data-num="6"></td><td><pre>          参数<span class="token number">2</span>：分区间的计算逻辑</pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">--3. 与 aggregateByKey 的区别：</span></pre></td></tr><tr><td data-num="8"></td><td><pre>       aggregate的初始值参与分区间和分区内的计算</pre></td></tr><tr><td data-num="9"></td><td><pre>       aggregateByKey的初始值只参与分区内的计算</pre></td></tr><tr><td data-num="10"></td><td><pre>       </pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">--4. 重点：初始值可以和集合数据的类型不一致，分区内和分区间最后的结果和初始值的类型一致，说明是可以起到转换结构的作用。</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre>println<span class="token punctuation">(</span>rdd<span class="token punctuation">.</span>aggregate<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_ <span class="token operator">+</span> _<span class="token punctuation">,</span> _ <span class="token operator">+</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//12</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    println<span class="token punctuation">(</span>rdd<span class="token punctuation">.</span>aggregate<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_ <span class="token operator">+</span> _<span class="token punctuation">,</span> _ <span class="token operator">+</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//42</span></pre></td></tr></table></figure><h5 id="55334-fold"><a class="anchor" href="#55334-fold">#</a> 5.5.3.34 fold</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：fold</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token punctuation">(</span>zeroValue: T<span class="token punctuation">)</span><span class="token punctuation">(</span>op: <span class="token punctuation">(</span>T<span class="token punctuation">,</span> T<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> T<span class="token punctuation">)</span>: T </pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">--2. 作用：当 aggregate 的分区间和分区内的计算逻辑相同时，可以使用 fold 进行简化</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">--3. 要求：初始值数据类型和集合中的数据类型保持一致</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre>println<span class="token punctuation">(</span>rdd<span class="token punctuation">.</span>fold<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">(</span>_ <span class="token operator">+</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//42</span></pre></td></tr></table></figure><h5 id="55335-mapvalues"><a class="anchor" href="#55335-mapvalues">#</a> 5.5.3.35 mapValues</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：mapValues (形参)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：(f: V => U)，是一个函数，仅对 value 进行处理，key 不变</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">--3. 返回值：kv 类型的 RDD。</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">--4. 作用：对 value 的数据结构进行转换</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> rdd1<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>mapValues<span class="token punctuation">(</span>_ <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="55336-countbykey"><a class="anchor" href="#55336-countbykey">#</a> 5.5.3.36 countBykey</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：countBykey</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：无参</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">--3. 返回值：Map [K, Long]，返回一个元组</span></pre></td></tr><tr><td data-num="4"></td><td><pre>             元组的第一个元素：RDD中的<span class="token keyword">Key</span></pre></td></tr><tr><td data-num="5"></td><td><pre>             元组的第二个元素：RDD中<span class="token keyword">Key</span>出现的次数</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token comment">--4. 作用：计算 key 出现的次数</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">--5. 底层源码：</span></pre></td></tr><tr><td data-num="9"></td><td><pre>       a、调用mapValues算子，将V转换为<span class="token number">1</span></pre></td></tr><tr><td data-num="10"></td><td><pre>       b、然后再调用reduceByKey，将相同的<span class="token keyword">key</span>的<span class="token keyword">value</span>值进行相加</pre></td></tr><tr><td data-num="11"></td><td><pre>       c、最后转换成map结构</pre></td></tr><tr><td data-num="12"></td><td><pre>      self<span class="token punctuation">.</span>mapValues<span class="token punctuation">(</span>_ <span class="token operator">=</span><span class="token operator">></span> <span class="token number">1</span>L<span class="token punctuation">)</span><span class="token punctuation">.</span>reduceByKey<span class="token punctuation">(</span>_ <span class="token operator">+</span> _<span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toMap</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre>println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>countByKey<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">//Map(a -> 2, b -> 1)</span></pre></td></tr></table></figure><h5 id="55337-countbyvalues"><a class="anchor" href="#55337-countbyvalues">#</a> 5.5.3.37 countByValues</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：countByValues</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：无</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">--3. 返回值：Map [T, Long] ，返回一个元组</span></pre></td></tr><tr><td data-num="4"></td><td><pre>             元组的第一个元素：原数据的kv</pre></td></tr><tr><td data-num="5"></td><td><pre>             元组的第二个元素：原数据kv出现的次数</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token comment">--4. 作用：计算 value 出现的次数</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">--5. 源码：</span></pre></td></tr><tr><td data-num="9"></td><td><pre>       a、将原数据进行处理，<span class="token punctuation">(</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">(</span>v<span class="token punctuation">,</span><span class="token boolean">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>       b、调用countByKey算子，计算v出现的次数</pre></td></tr><tr><td data-num="11"></td><td><pre>      map<span class="token punctuation">(</span><span class="token keyword">value</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">value</span><span class="token punctuation">,</span> <span class="token boolean">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>countByKey<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre>println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>countByValue<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">//Map((a,1) -> 1, (b,1) -> 1, (a,2) -> 1)</span></pre></td></tr></table></figure><h5 id="55338-save"><a class="anchor" href="#55338-save">#</a> 5.5.3.38 save</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：</span></pre></td></tr><tr><td data-num="2"></td><td><pre>             saveAsTextFile</pre></td></tr><tr><td data-num="3"></td><td><pre>             savaAsObjectFile</pre></td></tr><tr><td data-num="4"></td><td><pre>             savaAsSequenceFile</pre></td></tr><tr><td data-num="5"></td><td><pre>     <span class="token comment">--2. 形参：无</span></pre></td></tr><tr><td data-num="6"></td><td><pre>     <span class="token comment">--3. 作用：将 RDD 的结果以不同的形式保存到文件中，其中 savaAsSequenceFile 要求数据结构的 kv 键值对</span></pre></td></tr></table></figure><h5 id="55339-foreach"><a class="anchor" href="#55339-foreach">#</a> 5.5.3.39 foreach</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">--1. 算子：foreach</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token comment">--2. 形参：无</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">--3. 作用：遍历 RDD 中的数据</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">--4. 算子与方法的区别：</span></pre></td></tr><tr><td data-num="5"></td><td><pre>       a、rdd<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>  <span class="token comment">-->foreach: 方法</span></pre></td></tr><tr><td data-num="6"></td><td><pre>       b、rdd<span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span>            <span class="token comment">-->foreach: 算子</span></pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre>       <span class="token number">1.</span>只要看到rdd的算子，一定要想到两个块，Driver和Executor</pre></td></tr><tr><td data-num="9"></td><td><pre>       <span class="token number">2.</span>算子逻辑代码是在分布式计算节点executor中执行的，算子以外代码是在Driver端执行</pre></td></tr><tr><td data-num="10"></td><td><pre>       <span class="token number">3.</span>foreach是算子时，那么将在不同的executor中同时执行，互不影响。</pre></td></tr><tr><td data-num="11"></td><td><pre>       <span class="token number">4.</span>foreach是方法时，那么是在当前的节点的内存中完成数据的循环。</pre></td></tr><tr><td data-num="12"></td><td><pre>       <span class="token number">5.</span>结果就是：两种方法的结果的顺序会不同。</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre>rdd<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span><span class="token comment">//1 4 5 2</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    println<span class="token punctuation">(</span><span class="token string">"====================="</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    rdd<span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>println<span class="token punctuation">)</span> <span class="token comment">//5 2 1 4</span></pre></td></tr></table></figure><h4 id="554-rdd的序列化"><a class="anchor" href="#554-rdd的序列化">#</a> 5.5.4 RDD 的序列化</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">1.</span>如果算子中使用了算子以外的对象，那么在执行时，需要保证这个对象能序列化</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">2.</span>样例类自动混入了可序列化特质</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">3.</span>Spark算子的操作都是闭包，所以闭包有可能用到外部的变量，如果包含了外部的变量，那么一定要保证这个外部变量可序列化，所以Spark在提交作业之前，应对闭包中的变量进行检测，这个操作我们称为闭包检测。</pre></td></tr></table></figure><ul><li>Kryo 序列化框架</li></ul><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>参考地址: https:<span class="token comment">//github.com/EsotericSoftware/kryo</span></pre></td></tr><tr><td data-num="2"></td><td><pre>Java的序列化能够序列化任何的类。但是比较重（字节多），序列化后，对象的提交也比较大。Spark出于性能的考虑，Spark2<span class="token punctuation">.</span><span class="token number">0</span>开始支持另外一种Kryo序列化机制。Kryo速度是<span class="token keyword">Serializable</span>的<span class="token number">10</span>倍。<span class="token string">"当RDD在Shuffle数据的时候，简单数据类型、数组和字符串类型已经在Spark内部使用Kryo来序列化"</span>。</pre></td></tr><tr><td data-num="3"></td><td><pre>"注意：即使使用Kryo序列化，也要继承<span class="token keyword">Serializable</span>接口。</pre></td></tr></table></figure><h4 id="555-rdd的依赖关系"><a class="anchor" href="#555-rdd的依赖关系">#</a> 5.5.5 RDD 的依赖关系</h4><ol><li>toDebugString: 打印当前 RDD 的血缘关系<ul><li>获取每个 RDD 的血缘关系</li></ul></li></ol><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//3.1 读取数据</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> str<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token string">"input"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    println<span class="token punctuation">(</span>str<span class="token punctuation">.</span>toDebugString<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">//3.2 扁平化数据</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">val</span> words<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> str<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span>_<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    println<span class="token punctuation">(</span>words<span class="token punctuation">.</span>toDebugString<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">//3.3 分组</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">val</span> wordtocount<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> Iterable<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> words<span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>word <span class="token keyword">=></span> word<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    println<span class="token punctuation">(</span>wordtocount<span class="token punctuation">.</span>toDebugString<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token comment">//3.4 结构化处理 =</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token keyword">val</span> wordcount<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> wordtocount<span class="token punctuation">.</span>map <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>      <span class="token keyword">case</span> <span class="token punctuation">(</span>word<span class="token punctuation">,</span> iter<span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">(</span>word<span class="token punctuation">,</span> iter<span class="token punctuation">.</span>size<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    println<span class="token punctuation">(</span>wordcount<span class="token punctuation">.</span>toDebugString<span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>打印结果：</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> input MapPartitionsRDD<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> at textFile at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">25</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token operator">|</span>  input HadoopRDD<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> at textFile at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">25</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> MapPartitionsRDD<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> at flatMap at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">29</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token operator">|</span>  input MapPartitionsRDD<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> at textFile at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">25</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="5"></td><td><pre> <span class="token operator">|</span>  input HadoopRDD<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> at textFile at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">25</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> ShuffledRDD<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> at groupBy at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">33</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="7"></td><td><pre> <span class="token operator">+</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> MapPartitionsRDD<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> at groupBy at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">33</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token operator">|</span>  MapPartitionsRDD<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> at flatMap at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">29</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token operator">|</span>  input MapPartitionsRDD<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> at textFile at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">25</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token operator">|</span>  input HadoopRDD<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> at textFile at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">25</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> MapPartitionsRDD<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> at map at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">38</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token operator">|</span>  ShuffledRDD<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span> at groupBy at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">33</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token operator">+</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> MapPartitionsRDD<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> at groupBy at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">33</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token operator">|</span>  MapPartitionsRDD<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> at flatMap at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">29</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token operator">|</span>  input MapPartitionsRDD<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> at textFile at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">25</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token operator">|</span>  input HadoopRDD<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> at textFile at Spark_WordCount<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">25</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></pre></td></tr></table></figure><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">1.</span> RDD的依赖关系:RDD与直接上级RDD之间的关系</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">2.</span> RDD的血缘关系：包含直接依赖和间接依赖</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">3.</span> 如果Spark的计算过程中某个节点计算失败，那么框架会重新计算</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">4.</span> Spark想要重新对失败的task重新计算，那么需要知道数据来源以及需要知道数据需要经过哪些计算</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">5.</span> RDD不保存数据，仅保持计算的逻辑</pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token number">6.</span> 依赖关系主要是用来解决容错计算</pre></td></tr></table></figure><ol start="2"><li>dependencies：获取当前 RDD 与直接上级的 RDD 的依赖关系</li></ol><ul><li>获取直接上级 RDD 的依赖关系</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">//3.2 扁平化数据</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token keyword">val</span> words<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> str<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span>_<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    println<span class="token punctuation">(</span>words<span class="token punctuation">.</span>dependencies<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">//3.3 分组</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">val</span> wordtocount<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> Iterable<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> words<span class="token punctuation">.</span>groupBy<span class="token punctuation">(</span>word <span class="token keyword">=></span> word<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    println<span class="token punctuation">(</span>wordtocount<span class="token punctuation">.</span>dependencies<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">//3.4 结构化处理</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token keyword">val</span> wordcount<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> wordtocount<span class="token punctuation">.</span>map <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>      <span class="token keyword">case</span> <span class="token punctuation">(</span>word<span class="token punctuation">,</span> iter<span class="token punctuation">)</span> <span class="token keyword">=></span> <span class="token punctuation">(</span>word<span class="token punctuation">,</span> iter<span class="token punctuation">.</span>size<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    println<span class="token punctuation">(</span>wordcount<span class="token punctuation">.</span>dependencies<span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>打印结果</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre>List<span class="token punctuation">(</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>spark<span class="token punctuation">.</span>OneToOneDependency<span class="token annotation punctuation">@4ca8dbfa</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>List<span class="token punctuation">(</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>spark<span class="token punctuation">.</span>ShuffleDependency<span class="token annotation punctuation">@4d654825</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>List<span class="token punctuation">(</span>org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>spark<span class="token punctuation">.</span>OneToOneDependency<span class="token annotation punctuation">@62db0521</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>依赖关系解析</li></ul><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 当前 RDD 与上级 RDD 有两种关系：</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token comment">-- 第一种：OneToOneDependency</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  指上游RDD的一个分区最多只能被下游RDD一个分区使用，称之为窄依赖，类比独生子女</pre></td></tr><tr><td data-num="4"></td><td><pre></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token comment">-- 第二种：ShuffleDependency</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  指上游RDD的一个分区被下游RDD的多个分区使用，称之为宽依赖，形成<span class="token number">1</span>对n的关系</pre></td></tr></table></figure><p>![image-20200608013041068](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200608013041.png)</p><p>![image-20200608013109377](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200608013109.png)</p><p>![image-20200608013128090](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200608013128.png)</p><h4 id="556-rdd阶段的划分"><a class="anchor" href="#556-rdd阶段的划分">#</a> 5.5.6 RDD 阶段的划分</h4><blockquote><p>阶段：stage</p></blockquote><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">1.</span> 如果Spark计算过程中存在落盘的操作，那么就应该划分阶段</pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">2.</span> 如果执行过程中没有落盘操作，那么就应该是一个完成的阶段</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">3.</span> 如果执行过程有落盘的操作，那么应该task应该一分为二</pre></td></tr></table></figure><blockquote><p>spark 中阶段的划分取决于 shuffle 依赖的个数：</p><p>阶段的个数 = shuffle 依赖的数量 + 1</p></blockquote><p>![image-20200608013517259](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200608013517.png)</p><h4 id="557-rdd任务的划分"><a class="anchor" href="#557-rdd任务的划分">#</a> 5.5.7 RDD 任务的划分</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 几个概念</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token number">1.</span> Application：应用程序，初始化一个sparkContext就会产生一个application</pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token number">2.</span> job：一个行动算子就会产生一个job</pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token number">3.</span> stage：宽依赖的个数 <span class="token operator">+</span> <span class="token number">1</span> </pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token number">4.</span> task：一个stage阶段中，最后一个RDD的分区个数就是task的个数。</pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">-- 特列：在转换算子中如果调用了行动算子，那么在转换算子的内部也会有 job 的提交。</span></pre></td></tr><tr><td data-num="8"></td><td><pre></pre></td></tr><tr><td data-num="9"></td><td><pre>application <span class="token operator">></span> job <span class="token operator">></span> stage <span class="token operator">></span> task ，每一层都是<span class="token number">1</span> 对N 的关系。</pre></td></tr></table></figure><h4 id="558-rdd的持久性"><a class="anchor" href="#558-rdd的持久性">#</a> 5.5.8 RDD 的持久性</h4><h5 id="5581-问题"><a class="anchor" href="#5581-问题">#</a> 5.5.8.1 问题</h5><pre><code class="language-sqlite">-- 问题
RDD中是不保存数据的，所以如果多个RDD需要共享其中一个RDD的数据，那么必须重头执行，效率非常低，所以需要将一些重复性比较高，比较耗时的操作的结果缓存起来，提高效率，这样，不需要重头执行。
</code></pre><p>![image-20200608192945181](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200608192945.png)</p><p>![image-20200608193135788](<span class="exturl" data-url="aHR0cHM6Ly9saWFuLXpwLm9zcy1jbi1zaGVuemhlbi5hbGl5dW5jcy5jb20vcGlj">https://lian-zp.oss-cn-shenzhen.aliyuncs.com/pic</span> GO/20200608193135.png)</p><h5 id="5582-cache"><a class="anchor" href="#5582-cache">#</a> 5.5.8.2 cache</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 上述问题的解决方法：将计算结果进行缓存，重复使用，提高效率</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">-- cache 解析：</span></pre></td></tr><tr><td data-num="4"></td><td><pre>        <span class="token number">1.</span> 缓存cache底层其实调用的persist方法</pre></td></tr><tr><td data-num="5"></td><td><pre>        <span class="token number">2.</span> persist方法在持久化数据时会采用不同的存储级别对数据进行持久化操作</pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token number">3.</span> cache缓存的默认操作就是将数据保存到内存</pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token number">4.</span> cache存储的数据在内存中，如果内存不够用，executor可以将内存的数据进行整理，然后可以丢弃数据。</pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token number">5.</span> 如果由于executor端整理内存导致缓存的数据丢失，那么数据操作依然要重头执行。</pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token number">6.</span> 如果cache后的数据重头执行数据操作的话，那么必须要遵循血缘关系，所以cache操作不能删除血缘关系。</pre></td></tr><tr><td data-num="10"></td><td><pre>        <span class="token number">7.</span> cache操作在行动算子执行后，会在血缘关系中增加和缓存相关的依赖</pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token number">8.</span> cache操作不会切断血缘，一旦发生错误，可以重新执行。</pre></td></tr></table></figure><ul><li>验证缓存的现象</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">val</span> rdd1 <span class="token operator">=</span> rdd<span class="token punctuation">.</span>map<span class="token punctuation">(</span>num <span class="token keyword">=></span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>      println<span class="token punctuation">(</span><span class="token string">"map...."</span> <span class="token operator">+</span> num<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>      num</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token comment">// 将 RDD 的计算结果缓存到内存中</span></pre></td></tr><tr><td data-num="8"></td><td><pre>   rdd1<span class="token punctuation">.</span>cache<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre>    rdd1<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_ <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>print<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    println<span class="token punctuation">(</span><span class="token string">"\n*************"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre>    rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>foreach<span class="token punctuation">(</span>print<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token comment">// 未加 rdd1.cache () 代码，打印结果为：</span></pre></td></tr><tr><td data-num="15"></td><td><pre>        map<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.3</span></pre></td></tr><tr><td data-num="16"></td><td><pre>        map<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.1</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        map<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.4</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        map<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.2</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token number">2468</span></pre></td></tr><tr><td data-num="20"></td><td><pre>        <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span></pre></td></tr><tr><td data-num="21"></td><td><pre>        map<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.1</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        map<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.2</span></pre></td></tr><tr><td data-num="23"></td><td><pre>        map<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.3</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        map<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.4</span></pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token number">1234</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token comment">// 加 rdd1.cache () 代码以后，打印结果为：</span></pre></td></tr><tr><td data-num="27"></td><td><pre>        map<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.3</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        map<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.1</span></pre></td></tr><tr><td data-num="29"></td><td><pre>        map<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.4</span></pre></td></tr><tr><td data-num="30"></td><td><pre>        map<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">.2</span></pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token number">2468</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span></pre></td></tr><tr><td data-num="33"></td><td><pre>        <span class="token number">1234</span></pre></td></tr></table></figure><ul><li>验证缓存的依赖关系</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> rdd1 <span class="token operator">=</span> rdd<span class="token punctuation">.</span>map<span class="token punctuation">(</span>num <span class="token keyword">=></span> num<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    rdd1<span class="token punctuation">.</span>cache<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>toDebugString<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>toDebugString<span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">// 打印结果：</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> MapPartitionsRDD<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> at map at Spark3_persist<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">20</span> <span class="token punctuation">[</span>Memory Deserialized <span class="token number">1</span>x Replicated<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="9"></td><td><pre> <span class="token operator">|</span>  ParallelCollectionRDD<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> at makeRDD at Spark3_persist<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">18</span> <span class="token punctuation">[</span>Memory Deserialized <span class="token number">1</span>x Replicated<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> MapPartitionsRDD<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> at map at Spark3_persist<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">20</span> <span class="token punctuation">[</span>Memory Deserialized <span class="token number">1</span>x Replicated<span class="token punctuation">]</span></pre></td></tr><tr><td data-num="11"></td><td><pre> <span class="token operator">|</span>       CachedPartitions<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span> MemorySize<span class="token operator">:</span> <span class="token number">48.0</span> B<span class="token punctuation">;</span> ExternalBlockStoreSize<span class="token operator">:</span> <span class="token number">0.0</span> B<span class="token punctuation">;</span> DiskSize<span class="token operator">:</span> <span class="token number">0.0</span> B</pre></td></tr><tr><td data-num="12"></td><td><pre> <span class="token operator">|</span>  ParallelCollectionRDD<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> at makeRDD at Spark3_persist<span class="token punctuation">.</span>scala<span class="token operator">:</span><span class="token number">18</span> <span class="token punctuation">[</span>Memory Deserialized <span class="token number">1</span>x Replicated<span class="token punctuation">]</span></pre></td></tr></table></figure><h5 id="5583-persist"><a class="anchor" href="#5583-persist">#</a> 5.5.8.3 persist</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 问题：默认的缓存是存储在 Executor 端的内存中，数据量大的时候，该如何处理？</span></pre></td></tr><tr><td data-num="2"></td><td><pre>可以使用persist，将数据保存到当前RDD的磁盘中，但是依然有数据丢失风险。所以我们一般也不这么使用。</pre></td></tr><tr><td data-num="3"></td><td><pre> rdd1<span class="token punctuation">.</span>persist<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr></table></figure><ul><li>persist 的数据保存级别</li></ul><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">val</span> NONE <span class="token operator">=</span> <span class="token keyword">new</span> StorageLevel<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token keyword">val</span> DISK_ONLY <span class="token operator">=</span> <span class="token keyword">new</span> StorageLevel<span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token keyword">val</span> DISK_ONLY_2 <span class="token operator">=</span> <span class="token keyword">new</span> StorageLevel<span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">val</span> MEMORY_ONLY <span class="token operator">=</span> <span class="token keyword">new</span> StorageLevel<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token keyword">val</span> MEMORY_ONLY_2 <span class="token operator">=</span> <span class="token keyword">new</span> StorageLevel<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">val</span> MEMORY_ONLY_SER <span class="token operator">=</span> <span class="token keyword">new</span> StorageLevel<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>  <span class="token keyword">val</span> MEMORY_ONLY_SER_2 <span class="token operator">=</span> <span class="token keyword">new</span> StorageLevel<span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>  <span class="token keyword">val</span> MEMORY_AND_DISK <span class="token operator">=</span> <span class="token keyword">new</span> StorageLevel<span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  <span class="token keyword">val</span> MEMORY_AND_DISK_2 <span class="token operator">=</span> <span class="token keyword">new</span> StorageLevel<span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>  <span class="token keyword">val</span> MEMORY_AND_DISK_SER <span class="token operator">=</span> <span class="token keyword">new</span> StorageLevel<span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>  <span class="token keyword">val</span> MEMORY_AND_DISK_SER_2 <span class="token operator">=</span> <span class="token keyword">new</span> StorageLevel<span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="12"></td><td><pre>  <span class="token keyword">val</span> OFF_HEAP <span class="token operator">=</span> <span class="token keyword">new</span> StorageLevel<span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="5584-checkpoint"><a class="anchor" href="#5584-checkpoint">#</a> 5.5.8.4 checkPoint</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token number">1.</span> 将比较耗时，比较重要的数据一般会保存到分布式文件系统中。</pre></td></tr><tr><td data-num="2"></td><td><pre>   <span class="token number">2.</span> 使用<span class="token keyword">checkpoint</span>方法将数据保存到文件中</pre></td></tr><tr><td data-num="3"></td><td><pre>         SparkException: <span class="token keyword">Checkpoint</span> directory has <span class="token operator">not</span> been <span class="token keyword">set</span> <span class="token operator">in</span> the SparkContext</pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token number">3.</span> 执行<span class="token keyword">checkpoint</span>方法前应该设定检查点的保存目录</pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token number">4.</span> 检查点的操作中为了保证数据的准确性，执行时，会启动新的job</pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token number">5.</span> 为了提高性能，检查点操作一般会和cache联合使用，先将数据缓存到内存中，这样再进行<span class="token keyword">checkpoint</span>，这样在执行<span class="token keyword">checkpoint</span>的</pre></td></tr><tr><td data-num="7"></td><td><pre>       的时候，就不需重头执行。</pre></td></tr></table></figure><figure class="highlight scala"><figcaption data-lang="scala"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 设定检查点的保存目录</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  sc<span class="token punctuation">.</span>setCheckpointDir<span class="token punctuation">(</span><span class="token string">"output"</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token keyword">val</span> rdd<span class="token operator">:</span> RDD<span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token operator">=</span> sc<span class="token punctuation">.</span>makeRDD<span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">val</span> rdd1 <span class="token operator">=</span> rdd<span class="token punctuation">.</span>map<span class="token punctuation">(</span>num <span class="token keyword">=></span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>     println<span class="token punctuation">(</span><span class="token string">"map..."</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="8"></td><td><pre>      num</pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token punctuation">)</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    <span class="token comment">// 缓存和检查点联合使用</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    rdd1<span class="token punctuation">.</span>cache<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>checkpoint<span class="token punctuation">(</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="13"></td><td><pre></pre></td></tr><tr><td data-num="14"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_ <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    println<span class="token punctuation">(</span>rdd1<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mkString<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr></table></figure><h5 id="5585-缓存和检查点区别"><a class="anchor" href="#5585-缓存和检查点区别">#</a> 5.5.8.5 缓存和检查点区别</h5><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 缓存和检查点区别</span></pre></td></tr><tr><td data-num="2"></td><td><pre> <span class="token number">1.</span> Cache缓存只是将数据保存起来，不切断血缘依赖。<span class="token keyword">Checkpoint</span>检查点切断血缘依赖。</pre></td></tr><tr><td data-num="3"></td><td><pre> <span class="token number">2.</span> Cache缓存的数据通常存储在磁盘、内存等地方，可靠性低。<span class="token keyword">Checkpoint</span>的数据通常存储在HDFS等容错、高可用的文件系统，可靠性高。</pre></td></tr><tr><td data-num="4"></td><td><pre> <span class="token number">3.</span> 建议对<span class="token keyword">checkpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span>的RDD使用Cache缓存，这样<span class="token keyword">checkpoint</span>的job只需从Cache缓存中读取数据即可，否则需要再从头计算一次RDD</pre></td></tr></table></figure><h4 id="559-分区器"><a class="anchor" href="#559-分区器">#</a> 5.5.9 分区器</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 1. 分区器类别：</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    a、<span class="token keyword">Hash</span>分区，<span class="token string">"默认分区器"</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    b、Range分区</pre></td></tr><tr><td data-num="4"></td><td><pre>    c、用户自定义分区</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">-- 2. 分区器的作用：</span></pre></td></tr><tr><td data-num="6"></td><td><pre>      直接决定了RDD分区的个数、RDD中每条数据经过Shuffle后进入哪个分区，进而决定了Reduce的个数</pre></td></tr><tr><td data-num="7"></td><td><pre></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token comment">--3. 说明</span></pre></td></tr><tr><td data-num="9"></td><td><pre>  a、只有<span class="token keyword">Key</span><span class="token operator">-</span><span class="token keyword">Value</span>类型的RDD才有分区器，非<span class="token keyword">Key</span><span class="token operator">-</span><span class="token keyword">Value</span>类型的RDD分区的值是None</pre></td></tr><tr><td data-num="10"></td><td><pre>  b、每个RDD的分区ID范围：<span class="token number">0</span> <span class="token operator">~</span> <span class="token punctuation">(</span>numPartitions <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>，决定这个值是属于那个分区的。</pre></td></tr><tr><td data-num="11"></td><td><pre></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token comment">-- 4 分区规则：</span></pre></td></tr><tr><td data-num="13"></td><td><pre>   <span class="token keyword">Hash</span>分区：对于给定的<span class="token keyword">key</span>，计算其hashCode<span class="token punctuation">,</span>并除以分区个数取余</pre></td></tr><tr><td data-num="14"></td><td><pre>   Range分区：将一定范围内的数据映射到一个分区中，尽量保证每个分区数据均匀，而且分区间有序</pre></td></tr></table></figure><p>​</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2020-08-31 12:08:31" itemprop="dateModified" datetime="2020-08-31T12:08:31+08:00">2020-08-31</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Miyazono 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Miyazono 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Miyazono 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Miyazono <i class="ic i-at"><em>@</em></i>冬樱茶</li><li class="link"><strong>本文链接：</strong> <a href="https://github.com/Mayizono/miyazono.github.io/big-data/spark/2.Spark%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%BC%96%E7%A8%8B/">https://github.com/Mayizono/miyazono.github.io/big-data/spark/2.Spark架构及编程/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/big-data/flink/%E6%A8%A1%E5%9D%97%E6%80%BB%E7%BB%93/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeun65urj20zk0m81ii.jpg" title="未命名"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>未命名</h3></a></div><div class="item right"><a href="/big-data/spark/3.Spark%E7%BC%96%E7%A8%8B2/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexw3o58j20zk0m8e81.jpg" title="未命名"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>未命名</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#spark%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">Spark 架构及编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5spark%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">1.1.</span> <span class="toc-text">接 Spark 环境的安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-spark%E8%BF%90%E8%A1%8C%E6%A1%86%E6%9E%B6"><span class="toc-number">1.2.</span> <span class="toc-text">四、Spark 运行框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E8%BF%90%E8%A1%8C%E6%A1%86%E6%9E%B6"><span class="toc-number">1.2.1.</span> <span class="toc-text">4.1 运行框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.2.</span> <span class="toc-text">4.2 核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#421-%E6%89%A7%E8%A1%8C%E5%99%A8exerutor"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">4.2.1 执行器 Exerutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#422-%E5%B9%B6%E8%A1%8C%E5%BA%A6parallelism"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">4.2.2 并行度（Parallelism）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#423-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BEdag"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">4.2.3 有向无环图（DAG）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#424-%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4.2.4 提交流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-spark%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">五、Spark 核心编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#51-rdd"><span class="toc-number">1.3.1.</span> <span class="toc-text">5.1 RDD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52-io"><span class="toc-number">1.3.2.</span> <span class="toc-text">5.2 IO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53-rdd%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.3.</span> <span class="toc-text">5.3 RDD 执行原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54-rdd%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.4.</span> <span class="toc-text">5.4 RDD 的核心属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#541-%E5%88%86%E5%8C%BA%E5%88%97%E8%A1%A8"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">5.4.1 分区列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#542-%E5%88%86%E5%8C%BA%E8%AE%A1%E7%AE%97%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">5.4.2 分区计算函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#543-rdd%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">5.4.3 RDD 之间的依赖关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#544-%E5%88%86%E5%8C%BA%E5%99%A8%E5%8F%AF%E9%80%89"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">5.4.4 分区器（可选）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#545-%E9%A6%96%E9%80%89%E4%BD%8D%E7%BD%AE%E5%8F%AF%E9%80%89"><span class="toc-number">1.3.4.5.</span> <span class="toc-text">5.4.5 首选位置（可选）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B"><span class="toc-number">1.3.5.</span> <span class="toc-text">5.5 基础编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#551-%E5%88%9B%E5%BB%BArdd"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">5.5.1 创建 RDD</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5511-%E4%BB%8E%E5%86%85%E5%AD%98%E9%9B%86%E5%90%88%E4%B8%AD%E5%88%9B%E5%BB%BA"><span class="toc-number">1.3.5.1.1.</span> <span class="toc-text">5.5.1.1 从内存 (集合) 中创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5512-%E4%BB%8E%E5%A4%96%E9%83%A8disk%E5%AD%98%E5%82%A8%E4%B8%AD%E5%88%9B%E5%BB%BArdd"><span class="toc-number">1.3.5.1.2.</span> <span class="toc-text">5.5.1.2 从外部 (Disk) 存储中创建 RDD</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#552-%E5%B9%B6%E8%A1%8C%E5%BA%A6%E4%B8%8E%E5%88%86%E5%8C%BA"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">5.5.2 并行度与分区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5521-%E4%BB%8E%E5%86%85%E5%AD%98%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.5.2.1.</span> <span class="toc-text">5.5.2.1 从内存中读取数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5522-%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.5.2.2.</span> <span class="toc-text">5.5.2.2 从文件中读取数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#553-rdd%E7%AE%97%E5%AD%90"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">5.5.3 RDD 算子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5531-map"><span class="toc-number">1.3.5.3.1.</span> <span class="toc-text">5.5.3.1 map</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5532-mappartitions"><span class="toc-number">1.3.5.3.2.</span> <span class="toc-text">5.5.3.2 mapPartitions</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5533-mappartitionswithindex"><span class="toc-number">1.3.5.3.3.</span> <span class="toc-text">5.5.3.3 mapPartitionsWithIndex</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5534-flatmap"><span class="toc-number">1.3.5.3.4.</span> <span class="toc-text">5.5.3.4 flatmap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5535-glom"><span class="toc-number">1.3.5.3.5.</span> <span class="toc-text">5.5.3.5 glom</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5536-groupby"><span class="toc-number">1.3.5.3.6.</span> <span class="toc-text">5.5.3.6 groupBy</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5537-filter"><span class="toc-number">1.3.5.3.7.</span> <span class="toc-text">5.5.3.7 filter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5538-sample"><span class="toc-number">1.3.5.3.8.</span> <span class="toc-text">5.5.3.8 Sample</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5539-distinct"><span class="toc-number">1.3.5.3.9.</span> <span class="toc-text">5.5.3.9 distinct</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55310-coalesce"><span class="toc-number">1.3.5.3.10.</span> <span class="toc-text">5.5.3.10 coalesce</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55311-repartition"><span class="toc-number">1.3.5.3.11.</span> <span class="toc-text">5.5.3.11 rePartition</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55312-sortby"><span class="toc-number">1.3.5.3.12.</span> <span class="toc-text">5.5.3.12 sortBy</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55313-%E5%8F%8Cvalue%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.5.3.13.</span> <span class="toc-text">5.5.3.13 双 Value 数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55314-key-value%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.5.3.14.</span> <span class="toc-text">5.5.3.14 key-value 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55315-partitionby"><span class="toc-number">1.3.5.3.15.</span> <span class="toc-text">5.5.3.15 partitionBy</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55316-reducebykey"><span class="toc-number">1.3.5.3.16.</span> <span class="toc-text">5.5.3.16 reduceByKey</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55317-groupbykey"><span class="toc-number">1.3.5.3.17.</span> <span class="toc-text">5.5.3.17 groupByKey</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55318-aggregatebykey"><span class="toc-number">1.3.5.3.18.</span> <span class="toc-text">5.5.3.18 aggregateByKey</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55319-combinebykey"><span class="toc-number">1.3.5.3.19.</span> <span class="toc-text">5.5.3.19 combineByKey</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55320-%E5%87%A0%E4%B8%AAbykey%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.5.3.20.</span> <span class="toc-text">5.5.3.20 几个 ByKey 的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55321-sortbykey"><span class="toc-number">1.3.5.3.21.</span> <span class="toc-text">5.5.3.21 sortByKey</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55322-join"><span class="toc-number">1.3.5.3.22.</span> <span class="toc-text">5.5.3.22 join</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55323-leftrightouterjoin"><span class="toc-number">1.3.5.3.23.</span> <span class="toc-text">5.5.3.23 Left&#x2F;rightOuterJoin</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55324-cogroup"><span class="toc-number">1.3.5.3.24.</span> <span class="toc-text">5.5.3.24 cogroup</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55325-%E8%A1%8C%E5%8A%A8%E7%AE%97%E5%AD%90"><span class="toc-number">1.3.5.3.25.</span> <span class="toc-text">5.5.3.25 行动算子</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55326-reduce"><span class="toc-number">1.3.5.3.26.</span> <span class="toc-text">5.5.3.26 reduce</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55327-collect"><span class="toc-number">1.3.5.3.27.</span> <span class="toc-text">5.5.3.27 collect</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55328-count"><span class="toc-number">1.3.5.3.28.</span> <span class="toc-text">5.5.3.28 count</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55329-first"><span class="toc-number">1.3.5.3.29.</span> <span class="toc-text">5.5.3.29 first</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55330-take"><span class="toc-number">1.3.5.3.30.</span> <span class="toc-text">5.5.3.30 take</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55331-takeordered"><span class="toc-number">1.3.5.3.31.</span> <span class="toc-text">5.5.3.31 takeOrdered</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55332-sum"><span class="toc-number">1.3.5.3.32.</span> <span class="toc-text">5.5.3.32 sum</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55333-aggregate"><span class="toc-number">1.3.5.3.33.</span> <span class="toc-text">5.5.3.33 aggregate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55334-fold"><span class="toc-number">1.3.5.3.34.</span> <span class="toc-text">5.5.3.34 fold</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55335-mapvalues"><span class="toc-number">1.3.5.3.35.</span> <span class="toc-text">5.5.3.35 mapValues</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55336-countbykey"><span class="toc-number">1.3.5.3.36.</span> <span class="toc-text">5.5.3.36 countBykey</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55337-countbyvalues"><span class="toc-number">1.3.5.3.37.</span> <span class="toc-text">5.5.3.37 countByValues</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55338-save"><span class="toc-number">1.3.5.3.38.</span> <span class="toc-text">5.5.3.38 save</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#55339-foreach"><span class="toc-number">1.3.5.3.39.</span> <span class="toc-text">5.5.3.39 foreach</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#554-rdd%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">5.5.4 RDD 的序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#555-rdd%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.5.5.</span> <span class="toc-text">5.5.5 RDD 的依赖关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#556-rdd%E9%98%B6%E6%AE%B5%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">1.3.5.6.</span> <span class="toc-text">5.5.6 RDD 阶段的划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#557-rdd%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">1.3.5.7.</span> <span class="toc-text">5.5.7 RDD 任务的划分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#558-rdd%E7%9A%84%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">1.3.5.8.</span> <span class="toc-text">5.5.8 RDD 的持久性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5581-%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.5.8.1.</span> <span class="toc-text">5.5.8.1 问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5582-cache"><span class="toc-number">1.3.5.8.2.</span> <span class="toc-text">5.5.8.2 cache</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5583-persist"><span class="toc-number">1.3.5.8.3.</span> <span class="toc-text">5.5.8.3 persist</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5584-checkpoint"><span class="toc-number">1.3.5.8.4.</span> <span class="toc-text">5.5.8.4 checkPoint</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5585-%E7%BC%93%E5%AD%98%E5%92%8C%E6%A3%80%E6%9F%A5%E7%82%B9%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.5.8.5.</span> <span class="toc-text">5.5.8.5 缓存和检查点区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#559-%E5%88%86%E5%8C%BA%E5%99%A8"><span class="toc-number">1.3.5.9.</span> <span class="toc-text">5.5.9 分区器</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Miyazono" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Miyazono</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">23</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">6</span> <span class="name">分类</span></a></div></nav><div class="social"><a href="https://github.com/amehime" title="https:&#x2F;&#x2F;github.com&#x2F;amehime" class="item github"><i class="ic i-github"></i></a> <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9hbWVoaW1l" title="https:&#x2F;&#x2F;twitter.com&#x2F;amehime"><i class="ic i-twitter"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9ydXJpc216aw==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;rurismzk"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTEyODg2ODIz" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;12886823"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20vYW1laGltZQ==" title="https:&#x2F;&#x2F;weibo.com&#x2F;amehime"><i class="ic i-weibo"></i></span> <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS9hbWVoaW1l" title="https:&#x2F;&#x2F;about.me&#x2F;amehime"><i class="ic i-address-card"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li><li class="item"><a href="/mikutap/" rel="section"><i class="ic i-star"></i>mikutap</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/big-data/flink/%E6%A8%A1%E5%9D%97%E6%80%BB%E7%BB%93/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/big-data/spark/3.Spark%E7%BC%96%E7%A8%8B2/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/big-data/spark/1.Spark%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/big-data/spark/2.Spark%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%BC%96%E7%A8%8B/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/big-data/spark/3.Spark%E7%BC%96%E7%A8%8B2/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/big-data/spark/5.Spark%E4%B9%8BWordCount/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/big-data/" title="分类于 大数据">大数据</a> <i class="ic i-angle-right"></i> <a href="/categories/big-data/kafka/" title="分类于 Kafka">Kafka</a></div><span><a href="/big-data/kafka/Kafka%E6%80%BB%E7%BB%93/" title="Kafka学习">Kafka学习</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/big-data/" title="分类于 大数据">大数据</a> <i class="ic i-angle-right"></i> <a href="/categories/big-data/hive/" title="分类于 Hive">Hive</a></div><span><a href="/big-data/hive/HQL%E7%BB%83%E4%B9%A0%E9%A2%98/" title="HQL练习题">HQL练习题</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/big-data/" title="分类于 大数据">大数据</a> <i class="ic i-angle-right"></i> <a href="/categories/big-data/flume/" title="分类于 Flume">Flume</a></div><span><a href="/big-data/flume/Flume%E7%BB%83%E4%B9%A0%E9%A2%98/" title="Flume练习题">Flume练习题</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/big-data/flink/5_%E6%97%A5%E6%B4%BB/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/big-data/spark/8.Spark%E5%86%85%E6%A0%B8/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/big-data/" title="分类于 大数据">大数据</a> <i class="ic i-angle-right"></i> <a href="/categories/big-data/flink/" title="分类于 Flink">Flink</a></div><span><a href="/big-data/flink/1_Nginx/" title="负载均衡Nginx的使用">负载均衡Nginx的使用</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Miyazono @ Yume Shoka</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">323k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:54</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<a href="https://github.com/amehime/hexo-theme-shoka">Shoka</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"big-data/spark/2.Spark架构及编程/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->